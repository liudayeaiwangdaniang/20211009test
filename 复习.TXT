一、软件基础知识
1.软件项目成员有哪些？
•项目经理： 驱动整个项目的运转，负责制定计划，安排人力，管理进度，协调团队，进行重大决策。

•产品经理(需求开发人员)： 和客户沟通需求,并制定产品需求

•架构师 / 系统工程师： 技术专家，经验丰富，负责整个系统的体系架构的设计以及关键模块的设计。

•程序员 / 开发人员： 设计、编写软件，并修复软件中的缺陷。

•测试工程师： 负责找出软件产品存在的问题并报告。

•资料工程师： 负责编写软件产品附带的文件和联机帮助文档

•配置管理员： 负责管理程序员写的代码和资料工程师写的文档资料，并组合成一个软件包

•QA： 质量监管人员




2.软件的概念是什么？
定义:计算机系统中与硬件相互依存的一部分，它是包括程序,数据及其相关文档的完整集合
程序:按事先设计的功能和性能要求执行的指令序列
数据:使程序能正常操纵信息的数据结构
文档:与程序开发、维护和使用有关的图文资料

错误观点: "软件就是程序,软件开发就是编程序



3.你对软件测试的定义是怎么的？
定义:软件质量保证的一种手段
概念:是软件工程中的一个非常重要的环节,是开发项目整体的一部分。是有计划有组织的,是伴随软件工程的诞生而诞生的,软件测试不是万能的,不可能发现全部缺陷,软件测试是有局限性的。
目的:验证被测对象是否实现用户需求
弄清:实际结果与预期结果之间的差异


4.你对软件Bug的概念是怎样的？
你怎么定义是不是Bug？
软件没有实现产品的说明书所描述的功能。
软件实现了产品说明书描述不应有的功能。
软件执行了产品说明书没讲的操作。
软件没有实现产品说明书没描述但应该实现的功能(用户体验相关)。
从软件测试员的角度来看,软件难以理解、不易使用、运行缓慢,或者最终用户认为不对。

bug的类型都有哪些?
Bug ,有代码编写错误导致的功能问题

Defect 缺,实现与需求不一致

Fault即故障,由于环境系统问题引起运行失败

.Error即错误,语法错误,逻辑错误,不易发现



5.软件Bug级别有几种？

微小的==》一些小问题
如：错字,文字排版不整齐等,对功能几乎没有影响,软件产品仍可使用。

一般的==》不太严重的错误
如：主要功能模块部分丧失、提示信息不够准确、用户界面差和操作运行时间长等。

严重的==》严重错误
指功能模块和特性没有实现,主要功能部分丧失,次要功能全部丧失。

致命的==》严重的致命的错误
造成系统崩溃,四级,或造成数据丢失、主要功能完全丧失等。
如：死机、宕机、黑白屏无法使用、完全卡死



6.软件Bug状态有哪些？

激活状态==》问题没解决

测试人员新报告的缺陷或者验证后缺陷仍存在。

已修正状态==》开发人员针对缺陷

修正软件后已解决问题或已通过单元测试 。

关闭状态==》测试人员经过验证后,确认缺陷不存在之后的状态 。

遗留状态==》此次版本升级不修改，遗留到下一版本修改。

非错状态==》就是此问题不是一个Bug，开发可以直接置为关闭



7.你对软件质量是怎样定义的？

软件质量就是“软件与明确的和隐含的定义的需求相一致的程度”；

明确的需求指：软件符合明确叙述的功能和性能需求、文档中明确描述的开发标准；

隐含的需求指：所有专业开发的软件都应具有的隐含特征的程度，比如：符合行业标准。

内部质量:软件内部的设计和静态测试是否合格

过程质量:关注软件的整个生产流程是否规范是否合理

外部质量:关注软件产品本身的功能和性能表现

使用质量:关注软件在使用过程中易用性满意度的表现



8.软件质量的特性有哪些？

软件质量是软件测试的依据

问题一：软件质量的六大特性是什么？

答：功能性、可靠性、效率、易用性、可维护、可移植

(一般知道六大特性是啥就够了，但是预防会追问，还是浏览一遍下面的定义)



功能性

定义:软件在指定的使用环境下,满足用户显性或隐性需求的能力

适合性:软件为指定的任务和用户目标提供一组合适功能的能力

准确性:软件提供具有所需精确度的正确或相符的結果或效果的能力

互操作性:软件与一个或更多个的规定系统进行交互的能力



可靠性

定义:软件在指定的条件下使用,维持规定的性能级别的能力

成熟性:软件为避免由软件中错误而导致失控的能力,

容错性:在软件出现故障或违反指定接口的情况下,软件维持规定性能级别的能力,

易恢复性:在失效发生的情况下软件里重建规定的件能级别并恢复受直接影响的数据的能力

可靠性依从性:软件遵循与可靠件相关的标准,约定以及法律法规的能力



效率

定义:在规定的条件下,相对于所用资源的数量,软件提供适当性能的能力

时间特性:在规定的条件下软件执行其功能时,提供适当的响应和处理时间以及吞吐率的能力

资源利用性:在规定的条件下软件执行其能力时,使用合适的资源数量和类别的能力

效率依从件:软件遵循与效率相关的标准和约定的能力



易用性

定义:在指定的条件下使用时,软件被学习,理解,使用和吸引用户的能力

易理解性:软件的使用，用户能理解软件是否合适,以及如何将软件用于特定的任务和使用环境的能力

易学习:软件使用户能学习其应用的能力易操作性:软件使用用户操作和控制它的能力

吸引性:软件吸引用户的能力

易用性依从性:遭循与易用性相关的标准、约定风格指南或法规的能力



可维护

定义:软件可被修改的能力,修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的适应性

易分析性:软件诊断软件的缺陷,失效原因或识别待修改部分的能力,

易改变性:软件指定的修改可以被实现的能力

稳定性:软件避免由于软件修改而造成意外结果的能力,

易测试性:软件使已修改软件能被确认的能力

可维护依从性:遵循与维护相关标准和约定的能力,



可移植

定义:软件从一种环境迁移到另一种环境的能力

适用性:软件能适用于不同的环境的能力

易安装性:软件在指定环境中被安装的能力

共存性:软件在公共环境中同与其分享公共资源的其他独立软件共存的能力

易替换性:软件在同样的环境下,替代另一个相同用途的指定软件产品的能力

可移植性依从性:软件遵循可移植性相关的标准和约定的能力



9.软件生命周期概念是什么？

需求分析 —》可行性分析 —》概要设计 —》详细设计 —》编码实现 —》调试和测试 —》软件验收与应用 —》维护升级 —》废弃



10.软件测试目的是什么？

测试的目的不仅仅是为了发现软件缺陷与错误，而且也是对软件质量进行度量和评估，以提高软件的质量。

1.发现:被测对象与用户需求之间的差异

2.增加:用户对被测对象的质量信息

3.获取被测对象信息,为决策提供依据

4.为软件质量的可持续运行提供保障


5.预防Bug,降低风险



11.软件测试原则是什么？

1.测试证明软件存在缺陷

2.不可能执行穷尽测试,基于风险的测试是必须的

3.测试应该尽早启动,尽早接入

4.缺陷存在集群现象( 80/20原则)

5.杀虫剂悖论

6.不同的测试活动依赖不同的测试背景

7.不存在缺陷的谬论

8.基于上下文不断调整测试策略/方式



基于测试是为了寻找软件的错误与缺陷，评估与提高软件质量，因此我们提出了这样的一组测试原则,如下所示。

1.所有的软件测试都应追溯到用户需求。

2.应当把“尽早地和不断地进行软件测试”作为软件测试者的座右铭。

3.完全测试是不可能的，测试需要终止。

4.测试无法显示软件潜在的缺陷。

5.充分注意测试中的群集现象。

6.程序员应避免检查自己的程序。


7.尽量避免测试的随意性



12.测试分为哪几个阶段？
(1).单元测试
(2).集成测试
(3).系统测试

(4).验收测试



13.如何做好测试计划

5W原则：
(1).What (明确测试什么)
(2).Why（明确测试目标）
(3).When（明确项目开始时间、结束时间）
(4).How（明确测试方案）
(5).Where(明确资料的位置)



14.软件测试流程

第一步：

对要执行测试的产品/项目进行需求分析，确定测试策略，制定测试计划。该计划被审核批准后转向第二步。测试工作启动前一定要确定正确的测试策略和指导方针，这些是后期开展工作的基础。只有将本次的测试目标和要求分析清楚，才能决定测试资源的投入。

第二步：

设计测试用例。设计测试用例要根据测试需求和测试策略来进行，进度压力不大时，应该设计的详细，如果进度、成本压力较大，则应该保证测试用例覆盖到关键性的测试需求。该用例被批准后转向第三步。

第三步：

如果满足“启动准则”（EntryCriteria），那么执行测试。执行测试主要是搭建测试环境，执行测试用例。执行测试时要进行进度控制、项目协调等工作。

第四步：

提交缺陷。这里要进行缺陷审核和验证等工作。

第五步：

消除软件缺陷。通常情况下，开发经理需要审核缺陷，并进行缺陷分配。程序员修改自己负责的缺陷。在程序员修改完成后，进入到回归测试阶段。如果满足“完成准则”（ExitCriteria），那么正常结束测试。

第六步：

撰写测试报告。对测试进行分析，总结本次的经验教训，在下一次的工作中改。


软件测试过程管理，主要包括软件测试是什么样的过程，如何评价一个软件测试过程，如何进行配置管理和测试风险分析以及测试成本的管理。



15.了解测试流程吗？

需求分析【需求沟通，确定需求，功能点含义，】
需求评审【制定测试方案】
设计测试用例
用例评审
测试计划
搭建测试环境
测试执行
bug 处理
回归测试
测试报告
跟进上线



16.了解 bug 处理流程吗？



bug分级;优先级（高中低）、严重程度（高中低）
bug分类：UI、系统、接口
bug状态：新建、待修改、待验证、已验证、遗留、关闭



17.你工作中的沟通对象一般都是哪些人？

(1).产品、开发、UED

(2).市场、运维、运营


(3).领导、下属



18.常用的测试工具有哪些？

(1).网络调试工具:Fiddler

(2).页面调试工具: Chrome Inspector firebug

(3).WEB自动化工具：QTP、Selenium

(4).移动端工具: ADB,Monkey, MonkeyRunner

(5).移动端自动化框架:Appium 、Robotium 、Android、selendroid

(6).平台知识：windows、mac、android、Linux

(7).服务端压力工具Loadrunner、JMter


(8).mysql 可视化工具



19.如何设计测试用例、管理测试用例？

(1).测试用例设计原则

(2).测试用例设计方法

(3).测试用例管理方式



20.工作效率如何？都有哪些成果？

(1).如何安排任务的,如何提高测试效率?

(2).工作中的成果都有哪些?


(3).如何团队间协调工作的?



21.测试执行步骤是怎么样的？

1.部署测试环境

2.对测试用例进行分类

3.执行测试用例

4.记录测试结果，对缺陷进行分级分类


5.反馈缺陷并跟踪直至缺陷关闭



22.软件测试模型有哪些？

瀑布流

计划—>需求分析—>设计—>编码—>测试—>运行维护

瀑布模型是最正宗最规范的流程。

特点:

1,软件开发的各项活动严格按照线性方式进行。

2.当前活动接受上一项活动的工作结果。

3,当前活动的工作结果需要进行验证。

缺点:

1.由于开发模型是线性的,增加了开发的风险。

2,早期的错误可能要等到开发后期的阶段才能发现

V字形

W字型（双V）

螺旋型

制定计划—>风险分析—>实施工程(需求确认、软件需求、软件产品设计、设计确认与认证、详细设计、开发、测试)—>客户评估。

特点:

1.螺旋模型是将瀑布模型与快速原型模型结合起来

2.强调了其他模型所忽视的风险分析

3.每一次螺旋包括4个步骤:制定计划、风险分析、实施工程、客户评估

敏捷

特点：

1.短周期开发

2,增量开发

3,由程序员和测试人员编写的自动化测试来监控开发进度

4·通过口头沟通、测试和源代码来交流系统的结构和意图

5,编写代码之前先写测试代码,也叫做测试先行

缺点:

1,团队的组建较难,人员素质要求较高

2.对测试员要求完全掌握各种脚本语言编程,能执行单元测试、自动化测试

X模型

H模型

原型模型

客户与开发公司紧密联系,开发周期长。开发会受到需求变更的影响

特点:

1.实现客户与系统的交互。

2.进一步细化待开发软件需求。


3.开发人员可以确定客户的真正需求是什么





回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-27 14:31:14 1#
二、软件测试文档类内容

1.测试用例是怎么设计的？
用例设计：

1.对需求进行模块化分解；
2.使用科学有效的设计方法；

测试用例都有哪些设计方法
6种黑盒测试方法，如下：

1.等价类划分法 （有效、无效）
2.边界值分析法 (+1，-1)
3.因果图表法 （）
4.判定表方法
5.状态迁移法
6.正交实验法 （多组合交互组合测试）
7.错误推错法 (经验)
8.场景法 （登陆成功，成功后购买成功、登陆成功，成功后购买失败，登陆失败）

2.测试计划包含哪一些内容？
概述
1.1 测试目的
1.2 项目背景
1.3 测试要求与范围
1.4 预期读者
1.5 参考资料

测试环境
2.1 系统架构
2.2 软硬件环境要求
2.3 测试环境部署图

测试规划
3.1 测试范围
3.2 测试工具
3.3 人员、角色及职责

测试策略
4.1 系统框测试
4.2 业务流程测试
4.3 功能点测试
4.4 UI界面测试
4.5 性能测试
4.6 兼容性测试
4.7 安全测试

测试进度安排
测试风险分析
风险规避

3.测试方案包含哪些内容？
1.方案版本及时间
2.编写目的
3.编写人员
4.下面一大堆设计好的用例
4.测试报告包含有哪些内容？
测试报告包裹哪些概括说明
1,测试背景说明

2.测试范围说明

3·测试环境说明

4·测试方法说明

5.测试结果结论

6·质量或风险评估

1、首页
2、引言
2.1编写目的
2.2 项目背景
2.3术语和参考资料
3、测试概要
3.1测试方法(和工具)
3.2测试范围（测试用例设计）
3.3测试环境与配置
4、测试结果与缺陷分析
4.1测试执行情况与记录
4.1.1测试人员组织
4.1.2测试时间
4.1.3测试版本
4.2覆盖分析
4.2.1需求覆盖
4.2.2测试覆盖
4.3缺陷的统计与分析
4.3.1缺陷汇总
4.3.2缺陷分析
4.3.3残留缺陷与未解决问题

5、测试结论与建议
5.1 测试结论
1． 测试执行是否充分（可以增加对安全性、可靠性、可维护性和功能性描述）
2． 对测试风险的控制措施和成效
3． 测试目标是否完成
4． 测试是否通过
5． 是否可以进入下一阶段项目目标
5.2 建议
1．对系统存在问题的说明，描述测试所揭露的软件缺陷和不足，以及可能给软件实施和运行带来的影响
2．可能存在的潜在缺陷和后续工作
3．对缺陷修改和产品设计的建议
4．对过程改进方面的建议
6、附录
· 缺陷列表
· 缺陷等级定义标准
· 测试通过标准

(引用资料：https://baike.baidu.com/item/测试报告/10105092?fr=aladdin)

5.BS和CS架构有什么区别？
C/S是Client/Server或客户/服务器模式,如:杀毒软件

B/S是Brower/Server的缩写,如:慕课网网站


6.Alpha测试与Beta测试的区别？
Alpha测试是由一个用户在开发环境下进行的测试

Beta测试在用户真实环境测试,通过后进入发布阶段



7.作为开发人员，在开始编写代码之前，要经过哪些工作阶段？
需求分析、概要设计、详细设计



8.软件的规格说明书规定写完定稿后就绝对不能修改，会带来什么缺点？

互联网的产品更新换代快，可能规格说明书在定稿后过时，比如本来设计的需求在现在已经不适合了，那我们就不得不改规格说明书了。



9.软件产品研发过程的3个主要阶段是什么？

定义阶段、

开发阶段、

测试阶段、



10.画出瀑布模型，V模型？

•瀑布模型：计划、需求分析、设计、编码、测试、运行并维护

• v模型：用户需求、需求分析、概要设计、详细设计、编码、单元测试、集成测试、系统测试、验收测试。



11.软件测试分类

1.按照开发阶段划分软件测试：单元测试、集成测试、系统测试、验收测试。

2.按照测试实施组织划分软件测试：开发方测试、用户测试(alpha测试，Beta测试)、第三方测试。

3.按照测试技术划分：白盒测试、灰盒测试、黑盒测试。

软件测试方法和技术的分类与软件开发过程相关联，它贯穿了整个软件生命周期。



12.软件测试风险

1.软件测试中的软件风险分析是根据预测软件将出现的风险，制定软件测试计划并排列优先等级，风险分析是对软件中潜在的问题进行识别、估计和评价的过程。

2.风险也包括进度风险、质量风险、人员风险、变更风险、成本风险等



13.什么是敏捷测试？

•敏捷测试（敏捷开发引起）

首先敏捷测试(Agile testing)是测试的一种，原有测试定义中通过执行被测系统发现问题，通过测试这种活动能够提供对被测系统提供度量等概念还是适用的。



14.TDD（测试驱动开发，Test Driver Developer）

测试驱动开发的基本思想就是在开发功能代码之前，先编写测试用例。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完成全部功能的开发。



15.各种测试名词解释



什么是单元测试（Unit Testing）

1.单元测试是指对软件中的最小可测试单元进行检查和验证。

2.对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。

3.总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。

什么是集成测试(Integration Test)

1.集成测试，也叫组装测试或联合测试。

2.在单元测试的基础上，将所有模块按照设计要求（如根据结构图〕组装成为子系统或系统，进行集成测试。

3.实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。

集成测试的关注点：

1.在把各个模块连接起来时，穿越模块接口的数据是否会丢失。

2.各个子功能组合起来，能否达到预期的要求。

3.一个模块的功能是否会对另一个模块的功能产生不利的影响。

集成测试可以划分成3个级别：

1.模块内集成测试。

2.子系统内集成测试。

3.系统间集成测试。

什么是系统测试(System Testing)

1.将已经确认的软件、计算机硬件、外设、网络等其他元素结合在一起，进行信息系统的各种组装测试和确认测试.

2.系统测试是针对整个产品系统进行的测试

3.目的是验证系统是否满足了需求规格的定义，找出与需求规格不符或与之矛盾的地方，从而提出更加完善的方案

4.系统测试发现问题之后要经过调试找出错误原因和位置，然后进行改正。是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。

5.对象不仅仅包括需测试的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。

系统测试范围/策略

功能测试、性能测试、压力测试、容量测试、安全性测试、GUI测试、安装测试、配置测试、异常测试、备份测试、健壮性测试、文档测试、在线帮助测试、网络测试、稳定性测试

什么是验收测试(Acceptance Test)

1.它是一项确定产品是否能够满足合同或用户所规定需求的测试。这是管理性和防御性控制

2.主要确认软件是否按合同要求进行工作，既是否满足软件需求规格说明书中的要求。

验收测试分类：

1.非正式的验收测试

а测试（alpha）

软件开发公司组织内部人员模拟各类用户行为对即将上市的产品进行测试。

ß测试（beta）

软件开发公司组织各方面的的典型客户在日常工作中实际使用，并要求用户报告异常情况、提出改进意见，然后公司再进行完善。

2.正式的验收测试

有正规的测试过程，需要制定测试计划、定义测试方案、选择测试用例，进行测试，结果提交。着重考虑软件是否满足合同规定的所有功能和性能，文档资料是否完整、准确，人机界面和其他方面。

静态测试(Static Testing)



动态测试(Execution-Based Testing)

实际运行被测试的软件，输入相应的测试数据，检查界面的输出结果是否和预期结果相一致的过程。

黑盒测试(Black box)

把 软件看成一个黑盒子，不管内部逻辑和内部特性，只依据规格说明书检查程序的功能是否符合功能说明

白盒测试(White box)

又称为结构测试。着重于程序内部结构和算法，不关心功能和性能指标。

灰盒测试(Gray box)

介于白盒和黑盒测试之间，基于程序运行时刻的外部表现同时又结合程序内部逻辑结构来设计用例，执行程序并采集程序路径执行信息和外部用户接口结果的测试技术。

灰盒测试有啥缺点？

当然，凡事都有优点和缺点，灰盒测试自然也不例外。下面列举它的主要缺点。

◇不适用于简单的系统

　　 所谓的简单系统，就是简单到总共只有一个模块。由于灰盒测试关注于系统内部模块之间的交互。如果某个系统简单到只有一个模块，那就没必要进行灰盒测试了。

◇对测试人员的要求比黑盒测试高

　 从上面的介绍来看，灰盒测试要求测试人员清楚系统内部由哪些模块构成，模块之间如何协作。因此，对测试的要求就提高了。因此，会带来一定的培训成本。不过捏，依照俺的经验，培训难度不大。稍微有点基础的测试人员，都可以在短期培训之后胜任。

◇不如白盒测试深入

显然，灰盒不如白盒那么深入。不过捏，考虑到灰盒测试相比白盒测试有显著的成本优势，该缺点不是太明显。

回归测试(Regression Testing )

对软件的新版本测试时，重复执行上一个版本测试时使用的测试用例。防止出现“以前应用没有的问题现在出问题了” 。

冒烟测试（BVT测试（Build Verification Test ））

冒烟测试的对象是每一个新编译需要正式测试的版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作。冒烟测试，也叫预测试。

随机测试（又名猴子测试，探索性测试）

测试数据是随机产生的，在测试用例之外。只能作为一个测试的补充。

敏捷测试（敏捷开发引起）

首先敏捷测试(Agile testing)是测试的一种，原有测试定义中通过执行被测系统发现问题，通过测试这种活动能够提供对被测系统提供度量等概念还是适用的。

TDD（测试驱动开发，Test Driver Developer）

测试驱动开发的基本思想就是在开发功能代码之前，先编写测试用例。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完成全部功能的开发。







回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-27 15:31:37 2#
三、网络基础知识
现在做测试的出去面试，都会被问到linux，不会几个linux指令都不好意思说自己是做测试的了，本篇收集了几个被问的频率较高的linux面试题

1.linux 常用命令 — 基础命令
Linux基础命令
清除屏幕：clear

cd：切换目录

如：切换到D盘 cd D:

cd .. ： 返回上一级目录

如：现在在c:\list\tcp
命令： cd..
结果是：退到 c:\list

ls-l ：查看所有文件的详细信息

Is-a：列出当前目录下所有文件

touch：创建文件

如：创建mook 文件夹 touch mook

mkdir：创建目录

echo：创建带有内容的文件

如：echo"hello mook">mookhello
内容是：hello mook
文件名是：mookhello

cat：查看文件内容

如：查看mookhello文件里面的内容
命令：cat mookhello
结果是hello mook

cp：拷贝

如：拷贝mookhello的文件重置名为mook2
命令：cp mookhello mook2
再执行查看：ls-l
结果是：出现mook2 的文件夹
cat mook2的内容是否与mookhello 的相同

mv：移动或重命名

如：mook2 重命名为mook3；
命令：mv mook2 mook3

rm-f：强制删除

如：删除 mook 文件；
命令： rm-f mook

rm-f 不能删除有文件的目录；只能使用 rm-r：递归删除


rm-r：递归删除

如：删除 mooktest 目录
命令：rm-r mooktest

wc：统计文本中行数、字词、字符数

如：wc mookhello
结果：

1行 2字词 11个字符
cat mookhello


grep：在文本文件中查找某个字符串


tree：显示目录结构

In：创建软链

如：ln -s mookhello mook2
结果：

more, less：分页显示文本内容
head, tail：显示文件头尾内容
如下：



2.linux 常用命令 — 网络命令
curl：利用URL规则在命令行下工作的文件传输工具

如：抓取 mook 网的所有页面内容：curl www.mook.com

netstat：显示网络状态信息

如：netstat

telnet：用于登录远程主机

如：连接远程主机：telnet 127.0.0.1

3.linux 常用命令 — 系统命令
ping：测试网络连通

如：ping www.baidu.com
会看到给百度发送的报文和收到反馈，汇总信息


man：查看帮助

如：查看ping 的使用参数： man ping

top：查看系统进程，会有很多进程数，有PID
动态显示当前耗费资源最多进程信息

kill： 杀死进程

如：kill 38970

ps：显示瞬间进程状态df查看磁盘大小
df-h：带有单位显示磁盘信息
4. linux 命令示例
常用指令
1.说出10个linux常用的指令
ls 查看目录中的文件
cd /home 进入 '/ home' 目录；cd .. 返回上一级目录；cd ../.. 返回上两级目录mkdir dir1 创建一个叫做 'dir1' 的目录
rmdir dir1 删除一个叫做 'dir1' 的目录 （只能删除空目录）
rm -f file1 删除一个叫做 'file1' 的文件'，-f 参数，忽略不存在的文件，从不给出提示。
rm -rf /mulu 目录下面文件以及子目录下文件
cp /test1/file1 /test3/file2 如将/test1目录下的file1复制到/test3目录，并将文件名改为file2
mv /test1/file1 /test3/file2 如将/test1目录下的file1移动到/test3 目录，并将文件名改为file2
mv * ../ Linux当前目录所有文件移动到上一级目录
ps -ef|grep xxx 显示进程pid
kill 使用kill命令来终结进程。先使用ps命令找到进程id，使用kill -9命令，终止进程。
tar –xvf file.tar 解压 tar包
unzip file.zip 解压zip
unrar e file.rar 解压rar
free -m 查看服务器内存使用情况
ps查看进程

2.如何查看所有java进程

grep是搜索关键字

ps -ef | grep java

-aux 显示所有状态
ps -aux | grep java

kill 杀掉进程
3.如何杀掉某个服务的进程

kill 命令用于终止进程

-9 强迫进程立即停止

kill -9 [PID]

这里pid需要用 ps -ef | grep 查询pid

启动服务
4.如何启动服务

以启动Tomcat为例,先cd到启动的.sh文件目录

> cd /java/tomcat/bin
> ./startup.sh
停止Tomcat服务命令

./shutdown.sh

查看日志
5.如何查看测试项目的日志

一般测试的项目里面，有个logs的目录文件，会存放日志文件，有个xxx.out的文件，可以用tail -f 动态实时查看后端日志

先cd 到logs目录(里面有xx.out文件)

tail -f xx.out

这时屏幕上会动态实时显示当前的日志，ctr+c停止

6.如何查看最近1000行日志

tail -1000 xx.out

查看端口
7.LINUX中如何查看某个端口是否被占用

netstat -anp | grep 端口号

图中主要看监控状态为LISTEN表示已经被占用，最后一列显示被服务mysqld占用，查看具体端口号，只要有如图这一行就表示被占用了

查看82端口的使用情况，如图

netstat -anp |grep 82

可以看出并没有LISTEN那一行，所以就表示没有被占用。此处注意，图中显示的LISTENING并不表示端口被占用，不要和LISTEN混淆哦，查看具体端口时候，必须要看到tcp，端口号，LISTEN那一行，才表示端口被占用了

查看当前所有已经使用的端口情况，如图：

netstat -nultp（此处不用加端口号）

find查找文件
8.如何查找一个文件大小超过5M的文件

find . -type f -size +100M

9.如果知道一个文件名称，怎么查这个文件在linux下的哪个目录，如：要查找tnsnames.ora文件

find / -name tnsnames.ora

查到：
/opt/app/oracle/product/10.2/network/admin/tnsnames.ora
/opt/app/oracle/product/10.2/network/admin/samples/tnsnames.ora

还可以用locate 来查找

locate tnsnames.ora
结果是：
/opt/app/oracle/product/10.2/hs/admin/tnsnames.ora.sample
/opt/app/oracle/product/10.2/network/admin/tnsnames.ora
/opt/app/oracle/product/10.2/network/admin/samples/tnsnames.ora

10.find查找文件

find / -name httpd.conf　　#在根目录下查找文件httpd.conf，表示在整个硬盘查找
find /etc -name httpd.conf　　#在/etc目录下文件httpd.conf
find /etc -name 'srm'　　#使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件
find . -name 'srm*' 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件

按照文件特征查找 　　　　
find / -amin -10 　　# 查找在系统中最后10分钟访问的文件(access time)
find / -atime -2　　 # 查找在系统中最后48小时访问的文件
find / -empty 　　# 查找在系统中为空的文件或者文件夹
find / -group cat 　　# 查找在系统中属于 group为cat的文件
find / -mmin -5 　　# 查找在系统中最后5分钟里修改过的文件(modify time)
find / -mtime -1 　　#查找在系统中最后24小时里修改过的文件
find / -user fred 　　#查找在系统中属于fred这个用户的文件
find / -size +10000c　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)
find / -size -1000k 　　#查找出小于1000KB的文件
5.http/https协议
在PC浏览器的地址栏输入一串URL，然后按Enter键这个页面渲染出来，这个过程中都发生了什么事?这个是很多面试官喜欢问的一个问题
如果测试只是停留在表面上点点点，不知道背后的逻辑，是无法发现隐藏的bug，只能找一些页面上看得到的bug。
测试人员如果想在技术上有所提升，必然要都懂接口（API）测试，这也是近来年越来越多的公司意识到接口测试的重要性，招聘的时候要招一个中高级的测试人员，接口测试是必备技能了。

6.tcp 和 udp 的区别？

UDP：不需要连接成功也能发送成功数据；微信、QQ，自己账号没有登陆，别人也可以发送成功；只适合少量数据，否则容易丢失数据。
TCP：必须连接成功才能发送数据，适合大量数据。

7.socket建立连接的过程？

首先服务器建立监听, socket , bind , listen

然后客户端发送请求, connect , send

最后连接确认, accept , response

详细过程
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。
　　套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。

为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。

而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-27 17:46:45 3#
四、自动化测试
1.如何分层自动化测试？
针对不同的场景使用不同的自动化工具和方法

UI自动化回归

接口自动化

单元测试-白盒测试


2.如何降低自动化维护成本
   1.UI自动化，针对不常变的页面
   2.接口自动化，周期短、变动频繁
   3.框架分层，用例与框架分离

3.如何保证脚本的有效性？
保证定位有效性,封装处理异常,

保证流程有效性,封装独立方法

保证数据有效性,数据备份与恢复

4.什么是进程、线程、协程?
进程:独立数据空间,进程间不共享数据,系统调度。

线程:执行程序的最小单元,进程内线程间共享资源,系统调度。

协程:程序员调度,分解一个线程成为多个"微线程".



5.常见测试覆盖类型
1.语句覆盖

2.判定覆盖

3.条件覆盖

4.判定/条件覆

5.条件组合覆盖

6.路径覆盖


6.说一下面向对象的概念？
面向对象编程,简称OOP,是一种程序设计思想。

面向:动词
对象：名词

什么是对象？
对象是类的实例

什么是类？
是一类事务的统称，比如：人(黄种人、白人、黑人)

主要包括:类、继承、多态、实例、属性、方法

# encoding: utf-8

# Animal是类,相同事物的统称
class  Animal(object):
    def  run(self):
        print('Animal is running...')

# Dog类,继承于Animal类
class  Dog(Animal):
    pass

puppy =  Dog()
puppy.run()

# 多态,子类方法覆盖父类方法
class  Cat(Animal):
    def  __init__(self, name):
        # __name是属性
        self.__name = name

    def  getName(self):
        print(self.__name)

    def  run(self):
        print('Cat is running...')

# limi是一个猫类的实例
limi =  Cat("limi")
# run是实例的一个方法
limi.run()
# getName方法
limi.getName()

run后的结果：



7.python 笔试题

前言
现在面试测试岗位，一般会要求熟悉一门语言（python/java），为了考验求职者的基本功，一般会出2个笔试题，这些题目一般不难，主要考察基本功。
要是给你一台电脑，在编辑器里面边写边调试，没多大难度。主要是给你一张纸和笔，让你现场写出来，那就没那么容易了。
（本篇代码都是基于python3.6）

1.统计
问题1：统计在一个队列中的数字，有多少个正数，多少个负数，如[1, 3, 5, 7, 0, -1, -9, -4, -5, 8]

方法一
# coding:utf-8
a = [1, 3, 5, 7, 0, -1, -9, -4, -5, 8]

# 用列表生成式，生成新的列表
b = [i for i in a if i > 0]
print("大于0的个数：%s" % len(b))

c = [i for i in a if i < 0]
print("小于0的个数：%s" % len(c))
方法二

# coding:utf-8
a = [1, 3, 5, 7, 0, -1, -9, -4, -5, 8]

# 用传统的判断思维，累加
m = 0
n = 0
for i in a:
    if i > 0:
        m += 1
    elif i < 0:
        n += 1
    else:
        pass
print("大于0的个数：%s" % m)
print("小于0的个数：%s" % n)
2.字符串切片
问题1：字符串 "axbyczdj"，如果得到结果“abcd”

方法一
# 字符串切片
a = "axbyczdj"
print(a[::2])

方法二

# 传统思维
a = "axbyczdj"

c = []
for i in range(len(a)):
    if i % 2 == 0:
        c.append(a[i])
print("".join(c))
3.字符串切割
问题：已知一个字符串为“hello_world_yoyo”, 如何得到一个队列 ["hello","world","yoyo"]
a = "hello_world_yoyo"
b = a.split("_")
print(b)

4.格式化输出
问题1：已知一个数字为1，如何输出“0001”

a = 1

print("%04d" % a)
5.队列
问题1：已知一个队列,如： [1, 3, 5, 7], 如何把第一个数字，放到第三个位置，得到：[3, 5, 1, 7]

a = [1, 3, 5, 7]

# insert插入数据
a.insert(3, a[0])
print(a[1:])
6.交换
问题1：已知 a = 9, b = 8,如何交换a和b的值，得到a的值为8,b的值为9

方法1
a = 8
b = 9

a, b = b, a
print(a)
print(b)

方法2
a = 8
b = 9

# 用中间变量c
c = a
a = b
b = c
print(a)
print(b)

7.水仙花
问题1：打印出100-999所有的"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个"水仙花数"，因为153=1的三次方＋5的三次方＋3的三次方。
sxh = []
for i in range(100, 1000):
    s = 0
    m = list(str(i))
    for j in m:
        s += int(j)**len(m)
    if i == s:
        print(i)
        sxh.append(i)

print("100-999的水仙花数：%s" % sxh)

8.完全数
问题1：如果一个数恰好等于它的因子之和，则称该数为“完全数”，又称完美数或完备数。 例如：第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，
1+2+3=6。第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。
那么问题来了，求1000以内的完全数有哪些？

a = []

for i in range(1, 1000):
    s = 0
    for j in range(1, i):
        if i % j == 0 and j < i:
            s += j
    if s == i:
        print(i)
        a.append(i)
print("1000以内完全数：%s" % a)

9.排序
问题1：用python写个冒泡排序

a = [1, 3, 10, 9, 21, 35, 4, 6]

s = range(1, len(a))[::-1]
print(list(s))  # 交换次数

for i in s:
    for j in range(i):
        if a[j] > a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
    print("第 %s 轮交换后数据：%s" % (len(s)-i+1, a))
print(a)

10.sort排序
问题1：已知一个队列[1, 3, 6, 9, 7, 3, 4, 6]

按从小到大排序
按从大大小排序
去除重复数字
a = [1, 3, 6, 9, 7, 3, 4, 6]

# 1.sort排序，正序
a.sort()
print(a)

# 2.sort倒叙
a.sort(reverse=True)
print(a)

# 3.去重
b = list(set(a))
print(b)

11.计算n的阶乘
问题1：计算n!,例如n=3(计算321=6)， 求10!

方法1：可以用python里面的reduce函数，reduce() 函数会对参数序列中元素进行累积。
函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。
from functools import reduce

# 方法1：推荐！

a = 10
b = reduce(lambda x, y: x*y, range(1, a+1))
print(b)
如果不想用lamdba函数，可以定义一个函数
from functools import reduce

def chengfa(x, y):
    return x*y
a = 10
b = reduce(chengfa, range(1, a+1))
print(b)
方法2：自己写个递归函数
def digui(n):
    if n == 1:
        return 1
    else:
        return n*digui(n-1)

a = 10
print(digui(a))
方法3：用for循环（不推荐！）

a = 10
s = 1
for i in range(1, a+1):
    s = s*i
print(s)


12.斐波那契数列
问题1：已知一个数列：1、1、2、3、5、8、13、。。。。的规律为从3开始的每一项都等于其前两项的和，这是斐波那契数列。求满足规律的100以内的所以数据
a = 0
b = 1
while b < 100:
    print(b, end=",")
    a, b = b, a+b

13.幂的递归

计算x的n次方，如：3的4次方 为3*3*3*3=81
def mi(x, n):
    '''计算x 的n 次方'''
    if n == 0:
        return 1
    else:
        return x*mi(x, n-1)
x = 3
num = 4
print(mi(x, num))

14.汉诺塔问题(一般不会考)
汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘


当只有一个盘子的时候，只需要从将A塔上的一个盘子移到C塔上。
当A塔上有两个盘子是，先将A塔上的1号盘子（编号从上到下）移动到B塔上，再将A塔上的2号盘子移动的C塔上，最后将B塔上的小盘子移动到C塔上。
当A塔上有3个盘子时，先将A塔上编号1至2的盘子（共2个）移动到B塔上（需借助C塔），然后将A塔上的3号最大的盘子移动到C塔，最后将B塔上的两个盘子借助A塔移动到C塔上。
当A塔上有n个盘子是，先将A塔上编号1至n-1的盘子（共n-1个）移动到B塔上（借助C塔），然后将A塔上最大的n号盘子移动到C塔上，最后将B塔上的n-1个盘子借助A塔移动到C塔上。
综上所述，除了只有一个盘子时不需要借助其他塔外，其余情况均一样（只是事件的复杂程度不一样）。

def hanoi(n, a, b, c):
    '''汉诺塔问题'''
    if n == 1:
        print(a, '-->', c)
    else:
        hanoi(n - 1, a, c, b)
        print(a, '-->', c)
        hanoi(n - 1, b, a, c)

hanoi(5, 'A', 'B', 'C')

一般汉诺塔问题不会经常考，前面几个考的比较频繁


8.python笔试题 — 2

前言
本篇继续收集一些常见的python笔试题，以基础知识为主，递归是面试最喜欢考的一个问题，不管是做开发还是测试，都无法避免考递归。本篇结合实际案例，讲下几种关于递归的场景。

计算n的阶乘
计算n!,例如n=3(计算321=6)， 求10!

方法1：可以用python里面的reduce函数，reduce() 函数会对参数序列中元素进行累积。
函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。

from functools import reduce

# 方法1：推荐！

a = 10
b = reduce(lambda x, y: x*y, range(1, a+1))
print(b)

如果不想用lamdba函数，可以定义一个函数

from functools import reduce

def chengfa(x, y):
    return x*y
a = 10
b = reduce(chengfa, range(1, a+1))
print(b)
方法2：自己写个递归函数
def digui(n):
    if n == 1:
        return 1
    else:
        return n*digui(n-1)

a = 10
print(digui(a))
方法3：用for循环（不推荐！）
a = 10
s = 1
for i in range(1, a+1):
    s = s*i
print(s)
斐波那契数列
已知一个数列：1、1、2、3、5、8、13、。。。。的规律为从3开始的每一项都等于其前两项的和，这是斐波那契数列。求满足规律的100以内的所以数据

a = 0
b = 1
while b < 100:
    print(b, end=",")
    a, b = b, a+b
幂的递归
计算x的n次方，如：3的4次方 为3*3*3*3=81

def mi(x, n):
    '''计算x 的n 次方'''
    if n == 0:
        return 1
    else:
        return x*mi(x, n-1)
x = 3
num = 4
print(mi(x, num))
汉诺塔问题
汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘


当只有一个盘子的时候，只需要从将A塔上的一个盘子移到C塔上。
当A塔上有两个盘子是，先将A塔上的1号盘子（编号从上到下）移动到B塔上，再将A塔上的2号盘子移动的C塔上，最后将B塔上的小盘子移动到C塔上。
当A塔上有3个盘子时，先将A塔上编号1至2的盘子（共2个）移动到B塔上（需借助C塔），然后将A塔上的3号最大的盘子移动到C塔，最后将B塔上的两个盘子借助A塔移动到C塔上。
当A塔上有n个盘子是，先将A塔上编号1至n-1的盘子（共n-1个）移动到B塔上（借助C塔），然后将A塔上最大的n号盘子移动到C塔上，最后将B塔上的n-1个盘子借助A塔移动到C塔上。
综上所述，除了只有一个盘子时不需要借助其他塔外，其余情况均一样（只是事件的复杂程度不一样）。

def hanoi(n, a, b, c):
    '''汉诺塔问题'''
    if n == 1:
        print(a, '-->', c)
    else:
        hanoi(n - 1, a, c, b)
        print(a, '-->', c)
        hanoi(n - 1, b, a, c)

hanoi(5, 'A', 'B', 'C')
一般汉诺塔问题不会经常考，前面几个考的比较频繁



9.selenium面试题

面试web自动化必然会问到selenium，问selenium相关的问题定位是最基本的，也是自动化的根本，所以面试离不开元素定位问题。
之前看到招聘要求里面说“只会复制粘贴xpath的就不要投简历了”，说明面试官对求职者的自动化能力要求不能停留在复制粘贴上。
还是那句话，想学自动化的话，需牢记：录制穷三代，复制毁一生！

1.如何判断一个页面上元素是否存在？
这个可以说是被问烂的题了，判断元素存在方法有三种：

方法一，用try...except...

def is_element_exsist(driver, locator):
    '''
    判断元素是否存在,存在返回True,不存返回False
    :param locator: locator为元组类型，如("id", "yoyo")
    :return: bool值，True or False
    '''
    try:
        driver.find_element(*locator)
        return True
    except Exception as msg:
        print("元素%s找不到：%s" % (locator, msg))
        return False

if __name__ == '__main__':
    loc1 = ("id", "yoyo")  # 元素1
    print(is_element_exsist(driver, loc1))
方法二：用elements定义一组元素方法

def is_element_exsist1(driver, locator):
    '''
    判断元素是否存在,存在返回True,不存返回False
    :param locator: locator为元组类型，如("id", "yoyo")
    :return: bool值，True or False
    '''
    eles = driver.find_elements(*locator)
    if len(eles) < 1:
        return False
    else:
        return True

if __name__ == '__main__':
    loc1 = ("id", "yoyo")  # 元素1
    print(is_element_exsist1(driver, loc1))
(强烈推荐！)方法三：结合WebDriverWait和expected_conditions判断

from selenium import webdriver
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
def is_element_exsist2(driver, locator):
    '''
    结合WebDriverWait和expected_conditions判断元素是否存在,
    每间隔1秒判断一次，30s超时，存在返回True,不存返回False
    :param locator: locator为元组类型，如("id", "yoyo")
    :return: bool值，True or False
    '''
    try:
        WebDriverWait(driver, 30, 1).until(EC.presence_of_element_located(locator))
        return True
    except:
        return False
if __name__ == '__main__':
    loc1 = ("id", "yoyo")  # 元素1
    print(is_element_exsist2(driver, loc1))


2.如何提高脚本的稳定性？

相关类似问题还有“用例在运行过程中经常会出现不稳定的情况，也就是说这次可以通过，下次就没办法通过了，如何去提升用例的稳定性？”
“如何提高selenium脚本的执行速度？”
“selenium中如何保证操作元素的成功率？也就是说不管网络加载慢还是快”

如果一个元素今天你能定位到，过两天就定位不到了，只要这个页面没变过，说明定位方法是没啥问题的。
优化方向：1.不要右键复制xpath(十万八千里那种路径，肯定不稳定)，自己写相对路径，多用id为节点查找
2.定位没问题，第二个影响因素那就是等待了，sleep等待尽量少用（影响执行时间）
driver.implicitly_wait(30)这个等待也不要用,不要以为是全局的就是好事，有些js加载失败时候会一直等，并且页面跳转时候也无法识别
3.定位元素方法重新封装，结合WebDriverWait和expected_conditions判断元素方法，自己封装一套定位元素方法

from selenium import webdriver
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

def find(locator, timeout=30):
        '''定位元素，参数locator是元祖类型, 如("id", "yoyo")'''
        element = WebDriverWait(driver, timeout, 1).until(EC.presence_of_element_located(locator))
        return element

3.如何定位动态元素？
动态元素有2种情况，一个是属性动态，比如id是动态的，定位时候，那就不要用id定位就是了

<p id="yo" class="hello world">    
    <button id="yy_auto_1929292" name="heo" >登录</button>
    <br>
</p>
比如上面这个button元素，id是动态的，定位方法千千万，何必死在id上，可以用name定位，
哪怕这个元素属性都是动态的，它的标签不可能动态吧，那就定位父元素id="yo"啊:.//*[@id='yo']/button

还有一种情况动态的，那就是这个元素一会在页面上方，一会在下方，飘忽不定的动态元素，定位方法也是一样，按f12，根据元素属性定位（元素的tag、name的步伐属性是不会变的，动的只是class属性和styles属性）



4.如何通过子元素定位父元素？

面试官尽喜欢搞一些冷门的定位来考求职者，当初我也被这个问题送了小命。回来后专门查了相关资料，找到了这个定位方法

selenium里面通过父元素，定位子元素，可以通过二次定位来找到该元素:ele1 = driver.find_element_by_id("yoyo").find_element_by_id("ziyuans")
但是通过子元素找父元素这种思维之前真没注意过，实际上selenium里面提供了该方法

<p id="yo" class="hello world">
    <button id="yy_auto" name="heo" >登录</button>
    <br>
</p>
虽然用parent方法定位到了父元素，但是无法获取元素属性，也不能操作，没搞懂有啥意义

另外一个思路，子元素定位父元素，可以通过xpath的语法直接定位：.//*[@name="heo"]/..两个点..就是代表父级元素了



5.如果截取某一个元素的图片，不要截取全部图片

可以参考之前写过的这篇：https://www.cnblogs.com/yoyoketang/p/7748693.html

# coding:utf-8
from selenium import webdriver
from PIL import Image
driver = webdriver.Chrome()
driver.get('http://www.baidu.com/')

driver.save_screenshot('button.png')
element = driver.find_element_by_id("su")
print(element.location)                # 打印元素坐标
print(element.size)                    # 打印元素大小

left = element.location['x']
top = element.location['y']
right = element.location['x'] + element.size['width']
bottom = element.location['y'] + element.size['height']

im = Image.open('button.png')
im = im.crop((left, top, right, bottom))
im.save('button.png')
6.平常遇到过哪些问题?如何解决的

可以把平常遇到的元素定位的一些坑说下，然后说下为什么没定位到，比如动态id、有iframe、没加等待等因素

如何解决的--百度：上海-悠悠，上面都有解决办法



7.一个元素明明定位到了，点击无效（也没报错），如果解决？

使用js点击，selenium有时候点击元素是会失效



# js点击

js = 'document.getElementById("baidu").click()'
driver.execute_script(js)

8.selenium中隐藏元素如何定位？(hidden、display: none)

前言
面试题：selenium中隐藏元素如何定位？这个是很多面试官喜欢问的一个题，如果单纯的定位的话，隐藏元素和普通不隐藏元素定位没啥区别，用正常定位方法就行了
但是吧~~~很多面试官自己都搞不清楚啥叫定位，啥叫操作元素（如click,clear,send_keys）

隐藏元素
如下图有个输入框和一个登录的按钮，本来是显示的



元素的属性隐藏和显示，主要是type="hidden"和style="display: none;"属性来控制的，接下来在元素属性里面让它隐藏

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>这里有个按钮，是隐藏的

<!-- type="hidden" -->
<br>
输入账号<input id="yoyo" name="hello" type="hidden">

<!-- type="display: none;" -->
<br>
<button id="yy" name="heo" style="display: none;">登录</button>
<br>

<a hidden id="baidu" href="https://www.baidu.com">访问百度</a>
</p>

</body>
</html>
这样元素就不会显示了，也就是面试官所说的隐藏属性了



定位隐藏元素
前面说了，定位隐藏元素和普通的元素没啥区别，接下来就来验证下，是不是能定位到呢？

from selenium import webdriver

driver = webdriver.Firefox()
driver.get("http://localhost:63342/test1122/a/b.html")

# 定位type="hidden"隐藏元素
ele1 = driver.find_element_by_id("yoyo")
print("打印元素信息：%s" % ele1)

# 获取元素属性
print(ele1.get_attribute("name"))

# 判断元素是否隐藏
print(ele1.is_displayed())
运行结果：

打印元素信息：<selenium.webdriver.remote.webelement.WebElement (session="1debdd46-21b1-451e-b8a7-5aeff1d74f9d", element="{28628a87-7f22-4574-9e14-931f9c6f20e1}")>
hello
False
运行结果可以看出，隐藏元素用普通定位方法，事实上是定位到了呢！

操作隐藏元素
隐藏元素可以正常定位到，只是不能操作（定位元素和操作元素是两码事，很多初学者傻傻分不清楚），操作元素是click,clear,send_keys这些方法

# 隐藏输入框元素输入文本
ele1 = driver.find_element_by_id("yoyo")
ele1.send_keys("yoyo")
隐藏元素用send_keys()方法会抛异常'ElementNotVisibleException': Message: Element is not currently visible and so may not be interacted with
这个报错是说元素不可见，不可以被操作，同样的对“登录”按钮点击操作也是会报'ElementNotVisibleException'

# 点击隐藏登录框
ele2 = driver.find_element_by_id("yy")
ele2.click()
JS操作隐藏元素
如果面试官想问的是定位后操作隐藏元素的话，本质上说这个问题就是毫无意义的，web自动化的目的是模拟人的正常行为去操作。
如果一个元素页面上都看不到了，你人工也是无法操作的是不是？人工都不能操作，那你自动化的意义又在哪呢？所以这个只是为了单纯的考察面试者处理问题的能力，没啥实用性！（面试造飞机，进去拧螺丝）
既然面试官这么问了，那就想办法回答上给个好印象吧！
首先selenium是无法操作隐藏元素的（但是能正常定位到），本身这个框架就是设计如此，如果非要去操作隐藏元素，那就用js的方法去操作，selenium提供了一个入口可以执行js脚本。
js和selenium不同，只有页面上有的元素（在dom里面的），都能正常的操作，接下来用js试试吧！

<a hidden id="baidu" href="https://www.baidu.com">访问百度</a>这个链接是隐藏的，但是能用js点到

from selenium import webdriver

driver = webdriver.Firefox()
driver.get("http://localhost:63342/test1122/a/b.html")

# js点击hidden元素

js = 'document.getElementById("baidu").click()'
driver.execute_script(js)

运行完之后，会发现页面正常的点击，跳转到百度页面了

备注：百度搜到的可能方法是先用js去掉hidden属性，再用selenium操作，这个有点多此一举，你既然都已经会用js了，何必不一次性到位直接click呢？




















回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-28 17:40:45 4#
五、接口测试
接口测试最近几年被炒的火热了，越来越多的测试同行意识到接口测试的重要性。接口测试为什么会如此重要呢？
主要是平常的功能点点点，大家水平都一样，是个人都能点，面试时候如果问你平常在公司怎么测试的，你除了说点点点，还能说什么呢，无非就是这个项目点完了点那个项目，
这就是为什么各行各业的只要手指能点得动的人都来转行软件测试了。面试的时候面试官希望你除了点点点，还能更深入一点的思考页面上看不到的功能，也就是接口测试了。

一、接口测试常规面试题
1.为什么要做接口测试？
到底什么是接口测试，我们为什么要做接口测试？这是很多初入行的小伙伴的一个疑问，讲理论的你可能看不进去，接下来讲个实际案例，如下图一个提现功能

比如这个输入框，平常拿到这个web页面，会对输入框做用例设计：

输入一个负数（如：-100），点提交
输入金额为0（如：0），点提交
输入金额为0-100的数（如：20），点提交
输入金额为100（如：100），点提交
输入金额大于100（如：108），点提交
输入1位小数（如：10.1），点提交
输入2位小数（如：10.12），点提交
输入3位小数（如：10.123），点提交
按照这个等价类，边界值用例测完，页面上不能输入负数和大于3位数小数点，然后就可以上线了。
然而。。。突然有一天数据库里面插入了一个提现金额为负数（-100），于是整个部门炸锅了，首先找到测试（背锅）去复现问题，测试在页面上反复输入负数，无法提交，认为没问题啊！
首先前端开发对输入框是做了限制的，前端的web开发肯定没问题，这个锅前端开发MM不背。那么如果别人用户不通过你的web页面，直接发请求提交了呢？
纳尼！！！不通过页面也能提交。。。这就是我们接下来要提到的接口测试了。


2.你平常做接口测试的过程中发现过哪些bug?
这个问题其实回到起来很简单，只要做过接口测试的，总能发现几个BUG吧，把你平常发现的bug说2-3个就可以了。
面试官出这个题，主要是想知道你是不是真的做过接口测试，毕竟现在很多小伙伴简历都是写的假的（你要不写估计面试机会都没有，没办法，为了生存，能理解）
比如上面说的，提现输入框，在页面上输入负数，肯定是无法提交过去（前端页面会判断金额），如果我不走前端，直接用接口工具发请求，输入一个负数过去。
（假设服务端没做提现金额数据判断）
余额=当前余额（100）-提现金额（-100），那么提现-100，余额就变成200了，也就是越提现，余额越大了

可以用接口工具去直接请求接口，也可以fiddler抓包，抓到接口后修改金额为负数
所以，接口测试的必要性就体现出来了：
1.可以发现很多在页面上操作发现不了的bug
2.检查系统的异常处理能力
3.检查系统的安全性、稳定性
4.前端随便变，接口测好了，后端不用变
5.可以测试并发情况，一个账号，同时（大于2个请求）对最后一个商品下单，或不同账号，对最后一个商品下单
6.可以修改请求参数，突破前端页面输入限制（如金额）


3.平常你是怎么测试接口的？

通过性验证：
首先肯定要保证这个接口功能是好使的，也就是正常的通过性测试，按照接口文档上的参数，正常传入，是否可以返回正确的结果。

参数组合：
现在有一个操作商品的接口，有个字段type，传1的时候代表修改商品，商品id、商品名称、价格有一个是必传的，type传2的时候是删除商品，
商品id是必传的，这样的，就要测参数组合了，type传1的时候，只传商品名称能不能修改成功，id、名称、价格都传的时候能不能修改成功。

接口安全：
1、绕过验证，比如说购买了一个商品，它的价格是300元，那我在提交订单时候，我把这个商品的价格改成3元，后端有没有做验证，更狠点，我把钱改成-3，是不是我的余额还要增加？
2、绕过身份授权，比如说修改商品信息接口，那必须得是卖家才能修改，那我传一个普通用户，能不能修改成功，我传一个其他的卖家能不能修改成功
3、参数是否加密，比如说我登陆的接口，用户名和密码是不是加密，如果不加密的话，别人拦截到你的请求，就能获取到你的信息了，加密规则是否容易破解。
4、密码安全规则，密码的复杂程度校验

** 异常验证：**
所谓异常验证，也就是我不按照你接口文档上的要求输入参数，来验证接口对异常情况的校验。比如说必填的参数不填，输入整数类型的，传入字符串类型，长度是10的，传11，总之就是你说怎么来，我就不怎么来，其实也就这三种，必传非必传、参数类型、入参长度。

**性能测试 **
接口并发情况，如上面提到的：一个账号，同时（大于2个请求）对最后一个商品下单，或不同账号，对最后一个商品下单
接口响应时间，响应时间太长了，肯定需要优化，一般都是毫秒级别





4.平常用什么工具测接口的

接口测试工具很多，首先postman



其次用jmeter









5.webService接口是如何测试的

webService接口用SoapUI





6.没有接口文档，如果做接口测试？

没有接口文档，那还能咋办，瞎测呗！一个公司的开发流程里面，如果接口文档都没有，是无法展开接口测试的，你都不知道这个接口干什么的，也不知道具体每个字段代表什么意思，那还测啥呢？ --当然，你肯定不能回答面试官不测(心理mmp，脸上笑嘻嘻)，接下来就是扯犊子时间

1.没有接口文档，那就需要先跟开发沟通，然后整理接口文档（本来是开发写的，没办法，为了唬住面试官，先说自己整理了）
2.没有接口文档，可以抓包看接口请求参数，然后不懂的跟开发沟通

本题主要靠情商，通俗来说就是忽悠能力，先唬住面试官了再说，进去了也是瞎测测，随时做好背锅的准备



7.在手工接口测试或者自动化接口测试的过程中，上下游接口有数据依赖如何处理？

用一个全局变量来处理依赖的数据，比如登录后返回token,其它接口都需要这个token,那就用全局变量来传token参数



8.依赖于第三方数据的接口如何进行测试？

这个标准答案是：mock

接着面试官会问你，如果mock的，然后你就顺着坑继续挖，搭建mock服务，参考下面这篇【 mock-server之moco】[【https://www.cnblogs.com/yoyoketang/p/9348552.html】]

前言
mock除了用在单元测试过程中，还有一个用途，当前端开发在开发页面的时候，需要服务端提供API接口
此时服务端没开发完成，或者说没搭建测试环境，这个时候前端开发会自己mock一个api服务端，自己给自己提供调用接口的返回数据
mock-server用途就是开发在开发的过程中，需要依赖一部分的接口，但是对方没有提供或者环境等等情况

环境准备
1.moco-runner-0.12.0-standalone.jar
2.java 版本1.8.0_20
Moco环境搭建
1.moco是一个开源的框架，在github上可以下载到，github源码地址
目前最新版是moco-runner-0.12.0-standalone.jar，【点这里下载】

2.下载完成后，保存到电脑本地的一个目录，然后在同一目录下新建一个yoyo.json文件，里面写入如下内容：

[

  {
    "response" :
      {
        "text" : "Hello World! yoyoketang"
      }
  }
]
3.接下来启动moco服务，打开moco-runner-0.12.0-standalone.jar所在的文件夹目录（E:\moco），地址栏左上角输入cmd，回车打开cmd窗口

java -jar moco-runner-0.12.0-standalone.jar http -p 6666 -c yoyo.json




出现如下结果就是启动成功了

E:\moco>java -jar moco-runner-0.12.0-standalone.jar http -p 6666 -c yoyo.json
22 七月 2018 21:44:36 [main] INFO  Server is started at 6666
22 七月 2018 21:44:37 [main] INFO  Shutdown port is 62459
4.打开火狐浏览器(谷歌浏览器貌似打不开)地址栏输入：http://localhost:6666/看到如下界面，说明mock-server环境搭建成功



遇到的问题
1.刚开始jdk版本是1.6的,启动一直报错，报错信息如下:Unsupported major.minor version 51.0



2.百度搜了下，找到问题原因了，jdk版本和jar包不匹配导致。比如本机的JDK为1.6，但是项目编译时用的JDK为1.7那么就会出现这个异常，
因为本机JDK版本较低不能执行编译版本为高版本的Class文件，各JDK版本对应的错误编号如下：

J2SE 8 = 52,

J2SE 7 = 51,

J2SE 6.0 = 50,

J2SE 5.0 = 49,

JDK 1.4 = 48,

JDK 1.3 = 47,

JDK 1.2 = 46,

JDK 1.1 = 45

官方文档
1.更多参考资料，查阅官方文档，【点这里查看官方文档】



9.当一个接口出现异常时候，你是如何分析异常的？

1.抓包，用fiddler工具抓包，或者浏览器上f12,app上的话，那就用fiddler设置代理，去看请求报文和返回报文了
2.查看后端日志，xhell连上服务器，查看日志



10.如何模拟弱网测试

fiddler和charles都可以模拟弱网测试，平常说的模拟丢包，也是模拟弱网测试



11.如何分析一个bug是前端还是后端的？

平常提bug的时候，前端开发和后端开发总是扯皮，不承认是对方的bug
这种情况很容易判断，先抓包看请求报文，对着接口文档，看请求报文有没问题，有问题就是前端发的数据不对
请求报文没问题，那就看返回报文，返回的数据不对，那就是后端开发的问题咯



二、接口自动化面试题

前面总结了一篇关于接口测试的常规面试题，现在接口自动化测试用的比较多，也是被很多公司看好。那么想做接口自动化测试需要具备哪些能力呢？
也就是面试的过程中，面试官会考哪些问题，知道你是不是真的做过接口自动化测试？总的来说问的比较多的就是以下几个问题：

1.json和字典的区别？ -对基础数据类型的考察
2.测试的数据你放在哪？ -数据与脚本分离
3.参数化 - 数据驱动模式
4.下个接口请求参数依赖上个接口的返回数据 - 参数关联
5.依赖于登录的接口如何处理 -token和session的管理
6.依赖第三方的接口如何处理 -mock模拟数据返回
7.不可逆的操作，如何处理，比如删除一个订单这种接口如何测试 -造数据
8.接口产生的垃圾数据如何清理 - 数据清理
9.一个订单的几种状态如何全部测到，如：未处理，处理中，处理失败，处理成功 - 造数据，改数据库订单状态
10.python如何连接数据库操作？
11.其它的就是运行出报告、代码管理（git）、运行策略和持续集成jenkins相关了



1.json和字典dict的区别？

现在自动化培训烂大街，是个人都能说的上几个框架，面试如果问框架相关问题，求职者只需一瓶82年的雪碧，会吹的让你怀疑人生！
所以面试官为了更清楚的知道你是停留在表面上的花拳绣腿还是有扎实的基础，就不会问框架这种东西了。基本上问几个数据类型的基础就知道有没货了。

那么json和字典到底有什么区别呢?初学者连python的基础数据类型都没搞清楚，直接撸框架，有的人学了几个月可能都迷迷糊糊的，以为json就是字典。这个是肯定不对的。

首先python里面的基础数据类型有：int、str、 float、list、bool、tuple、dict、set这几种类型，里面没json这种数据类型。

JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。

由于你的代码是python写的（也有可能是php,java,c，ruby等语言）,但是后端接口是java写的（也有可能是其它语言），不同的语言数据类型是不一样的（就好比中国的语言和美国的语言数据类型也不一样，中国的一般说一只羊，一头牛，美国都是 a /an这种单位），所以就导致你提交的数据，别的开发语言无法识别，这就需要规范传输的数据（传输的数据都是一个字符串），大家都遵循一个规范，按一个标准的格式去传输，于是就有就json这种国际化规范的数据类型。

json本质上还是字符串，只是按key：value这种键值对的格式来的字符串

import json

# a是字典dict
a = {"a": 1, "b": 2, "c": True}

# b是json
b = '{"a": 1, "b": 2, "c": true}'

print(type(a))
print(json.dumps(a))   # a转json
运行结果

<class 'dict'>
{"a": 1, "b": 2, "c": true}
<class 'str'>
{'a': 1, 'b': 2, 'c': True}


2.测试的数据你放在哪?

测试数据到底该怎么放，这个是面试官最喜欢问的一个题了，似乎仁者见仁智者见智，没有标准的答案，有的人说放excel，也有的说放.py脚本，也有的说放ini配置文件，
还有放到json，yaml文件，txt文件，甚至有的放数据库，五花八门，一百个做自动化的小伙伴有100个放的地方。

这里总结下测试的数据到底该怎么放？

首先测试的数据是分很多种的，有登录的账户数据，也有注册的账户数据，还有接口的参数，还有邮箱配置的数据等等等等，所以这个题不能一概而论给答死了。要不然就是给自己挖坑。

以下两个大忌不能回答：

测试的数据是不能写死到代码里面的，这个是原则问题，也是写代码的大忌（你要是回答写在代码里面，估计就是回去等通知了）
测试数据放到.py的开头，这种其实很方便，对于少量的，固定不变的数据其实是可以放的，但是面试时候，千万不能这样说，面试官喜欢装逼的方法
测试数据存放总结：

1.对于账号密码，这种管全局的参数，可以用命令行参数，单独抽出来，写的配置文件里（如ini）
2.对于一些一次性消耗的数据，比如注册，每次注册不一样的数，可以用随机函数生成
3.对于一个接口有多组测试的参数，可以参数化，数据放yaml,text,json,excel都可以
4.对于可以反复使用的数据，比如订单的各种状态需要造数据的情况，可以放到数据库，每次数据初始化，用完后再清理
5.对于邮箱配置的一些参数，可以用ini配置文件
6.对于全部是独立的接口项目，可以用数据驱动方式，用excel/csv管理测试的接口数据
7.对于少量的静态数据，比如一个接口的测试数据，也就2-3组，可以写到py脚本的开头，十年八年都不会变更的

总之不同的测试数据，可以用不同的文件管理



3.什么是数据驱动，如何参数化？

参数化和数据驱动的概念这个肯定要知道的，参数化的思想是代码用例写好了后，不需要改代码，只需维护测试数据就可以了，并且根据不同的测试数据生成多个用例

import unittest
import ddt

# 测试数据
datas = [ {"user": "admin", "psw": "123", "result": "true"},
        {"user": "admin1", "psw": "1234", "result": "true"},
        {"user": "admin2", "psw": "1234", "result": "true"},
        {"user": "admin3", "psw": "1234", "result": "true"},
        {"user": "admin4", "psw": "1234", "result": "true"},
        {"user": "admin5", "psw": "1234", "result": "true"},
        {"user": "admin6", "psw": "1234", "result": "true"},
        {"user": "admin7", "psw": "1234", "result": "true"},
        {"user": "admin8", "psw": "1234", "result": "true"},
        {"user": "admin9", "psw": "1234", "result": "true"},
        {"user": "admin10", "psw": "1234", "result": "true"},
        {"user": "admin11", "psw": "1234", "result": "true"}]

@ddt.ddt
class Test(unittest.TestCase):

    @ddt.data(*datas)
    def test_(self, d):
        """上海-悠悠：{0}"""
        print("测试数据：%s" % d)

if __name__ == "__main__":
    unittest.main()


unittest框架还有一个paramunittest也可以实现



import unittest
import paramunittest
import time
# python3.6
# 作者：上海-悠悠

@paramunittest.parametrized(
    {"user": "admin", "psw": "123", "result": "true"},
    {"user": "admin1", "psw": "1234", "result": "true"},
    {"user": "admin2", "psw": "1234", "result": "true"},
    {"user": "admin3", "psw": "1234", "result": "true"},
    {"user": "admin4", "psw": "1234", "result": "true"},
    {"user": "admin5", "psw": "1234", "result": "true"},
    {"user": "admin6", "psw": "1234", "result": "true"},
    {"user": "admin7", "psw": "1234", "result": "true"},
    {"user": "admin8", "psw": "1234", "result": "true"},
    {"user": "admin9", "psw": "1234", "result": "true"},
    {"user": "admin10", "psw": "1234", "result": "true"},
    {"user": "admin11", "psw": "1234", "result": "true"},
)

class TestDemo(unittest.TestCase):
    def setParameters(self, user, psw, result):
        '''这里注意了，user, psw, result三个参数和前面定义的字典一一对应'''
        self.user = user
        self.user = psw
        self.result = result

    def testcase(self):
        print("开始执行用例：--------------")
        time.sleep(0.5)
        print("输入用户名：%s" % self.user)
        print("输入密码：%s" % self.user)
        print("期望结果：%s " % self.result)
        time.sleep(0.5)
        self.assertTrue(self.result == "true")


if __name__ == "__main__":
    unittest.main(verbosity=2)
如果用的是pytest框架，也能实现参数化

# content of test_canshu1.py

# coding:utf-8

import pytest
@pytest.mark.parametrize("test_input,expected",
                         [ ("3+5", 8),
                           ("2+4", 6),
                           ("6 * 9", 42),
                         ])
def test_eval(test_input, expected):
    assert eval(test_input) == expected

if __name__ == "__main__":
    pytest.main(["-s", "test_canshu1.py"])
pytest里面还有一个更加强大的功能，获得多个参数化参数的所有组合，可以堆叠参数化装饰器

import pytest
@pytest.mark.parametrize("x", [0, 1])
@pytest.mark.parametrize("y", [2, 3])
def test_foo(x, y):
    print("测试数据组合：x->%s, y->%s" % (x, y))


if __name__ == "__main__":
    pytest.main(["-s", "test_canshu1.py"])


4.下个接口请求参数依赖上个接口的返回数据

这个很容易，不同的接口封装成不同的函数或方法，需要的数据return出来，用一个中间变量a去接受，后面的接口传a就可以了
参考这篇【python接口自动化26-参数关联和JSESSIONID(上个接口返回数据作为下个接口请求参数)】



5.依赖于登录的接口如何处理？
登录接口依赖token的，可以先登录后，token存到一个yaml或者json，或者ini的配置文件里面，后面所有的请求去拿这个数据就可以全局使用了
参考之前分享的一篇python接口自动化24-有token的接口项目使用unittest框架设计

如果是cookies的参数，可以用session自动关联

s=requests.session()

后面请求用s.get()和s.post()就可以自动关联cookies了



6.依赖第三方的接口如何处理

这个需要自己去搭建一个mock服务，模拟接口返回数据，参考【python笔记25-mock-server之moco】(https://www.cnblogs.com/yoyoketang/p/9348552.html)

moco是一个开源的框架，在github上可以下载到https://github.com/dreamhead/moco

moco服务搭建需要自己能够熟练掌握，面试会问你具体如何搭建 ，如何模拟返回的数据，是用的什么格式，如何请求的



7.不可逆的操作，如何处理，比如删除一个订单这种接口如何测试

此题考的是造数据的能力，接口的请求数据，很多都是需要依赖前面一个状态的

比如工作流这种，流向不同的人状态不一样，操作权限不一样，测试的时候，每种状态都要测到,就需要自己会造数据了。

平常手工测试造数据，直接在数据库改字段状态。那么自动化也是一样，造数据可以用python连数据库了，做增删改查的操作

测试用例前置操作，setUp做数据准备

后置操作，tearDown做数据清理



8.接口产生的垃圾数据如何清理

跟上面一样，造数据和数据清理，需用python连数据库了，做增删改查的操作
测试用例前置操作，setUp做数据准备
后置操作，tearDown做数据清理



9.一个订单的几种状态如何全部测到，如：未处理，处理中，处理失败，处理成功

跟上面一样，也是考察造数据，修改数据的状态



10.python如何连接数据库操作？

这个就是详细的考察你是如何用python连数据库的，并且最好能现场写代码那种（有的笔试题就是python连数据库）
具体问你用到哪个模块，查询的数据是什么类型？如何删除数据？如何新增数据？如何修改数据？
PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。
详情参考教程http://www.runoob.com/python3/python3-mysql.html

#!/usr/bin/python3
# 查询EMPLOYEE表中salary（工资）字段大于1000的所有数据：
import pymysql
 
# 打开数据库连接
db = pymysql.connect("localhost","testuser","test123","TESTDB" )
 
# 使用cursor()方法获取操作游标 
cursor = db.cursor()
 
# SQL 查询语句
sql = "SELECT * FROM EMPLOYEE \
       WHERE INCOME > %s" % (1000)
try:
   # 执行SQL语句
   cursor.execute(sql)
   # 获取所有记录列表
   results = cursor.fetchall()
   for row in results:
      fname = row[0]
      lname = row[1]
      age = row[2]
      sex = row[3]
      income = row[4]
       # 打印结果
      print ("fname=%s,lname=%s,age=%s,sex=%s,income=%s" % \
             (fname, lname, age, sex, income ))
except:
   print ("Error: unable to fetch data")
 
# 关闭数据库连接
db.close()
其它的就是运行出报告、代码管理（git）、运行策略和持续集成jenkins相关了，这个所以的自动化但是一样的，后面会单独讲一篇jenkins持续集成相关



回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-30 10:24:27 5#
六、App测试
现在面试个测试岗位，都是要求全能的，web、接口、app啥都要会测，那么APP测试一般需要哪些技能呢？
面试app测试岗位会被问到哪些问题，怎样让面试管觉得你对APP测试很精通的样子？
本篇总结了app测试面试时候经常被问的10个相关问题
1.什么是activity?
2.Activity生命周期?
3.Android四大组件?
4.app测试和web测试有什么区别？
5.android和ios测试区别？
6.app出现ANR，是什么原因导致的？
7.App出现crash原因有哪些？
8.app对于不稳定偶然出现anr和crash时候你是怎么处理的？
9.app的日志如何抓取?
10.你平常会看日志吗, 一般会出现哪些异常（Exception）?

1、什么是activity？
activity


什么是activity，这个前两年出去面试APP测试岗位，估计问的最多了，特别是一些大厂，先问你是不是做过APP测试，那好，你说说什么是activity?
如果没看过android的开发原理，估计这个很难回答，要是第一个问题就被难住了，面试的信心也会失去一半了，士气大减。

Activity是Android的四大组件之一，也是平时我们用到最多的一个组件，可以用来显示View。
官方的说法是Activity一个应用程序的组件，它提供一个屏幕来与用户交互，以便做一些诸如打电话、发邮件和看地图之类的事情，原话如下：
An Activity is an application component that provides a screen with which users can interact in order to do something, such as dial the phone, take a photo, send an email, or view a map.

Activity是一个Android的应用组件，它提供屏幕进行交互。每个Activity都会获得一个用于绘制其用户界面的窗口，窗口可以充满哦屏幕也可以小于屏幕并浮动在其他窗口之上。
一个应用通常是由多个彼此松散联系的Activity组成，一般会指定应用中的某个Activity为主活动，也就是说首次启动应用时给用户呈现的Activity。将Activity设为主活动的方法
当然Activity之间可以进行互相跳转，以便执行不同的操作。每当新Activity启动时，旧的Activity便会停止，但是系统会在堆栈也就是返回栈中保留该Activity。
当新Activity启动时，系统也会将其推送到返回栈上，并取得用户的操作焦点。当用户完成当前Activity并按返回按钮时，系统就会从堆栈将其弹出销毁，然后回复前一Activity
当一个Activity因某个新Activity启动而停止时，系统会通过该Activity的生命周期回调方法通知其这一状态的变化。
Activity因状态变化每个变化可能有若干种，每一种回调都会提供执行与该状态相应的特定操作的机会


2、Activity生命周期?
周期即活动从开始到结束所经历的各种状态。生命周期即活动从开始到结束所经历的各个状态。从一个状态到另一个状态的转变，从无到有再到无，这样一个过程中所经历的状态就叫做生命周期。

Activity本质上有四种状态：

1.运行（Active/Running）:Activity处于活动状态，此时Activity处于栈顶，是可见状态，可以与用户进行交互

2.暂停（Paused）:当Activity失去焦点时，或被一个新的非全面屏的Activity，或被一个透明的Activity放置在栈顶时，Activity就转化为Paused状态。此刻并不会被销毁，只是失去了与用户交互的能力，其所有的状态信息及其成员变量都还在，只有在系统内存紧张的情况下，才有可能被系统回收掉

3.停止（Stopped）:当Activity被系统完全覆盖时，被覆盖的Activity就会进入Stopped状态，此时已不在可见，但是资源还是没有被收回

4.系统回收（Killed）:当Activity被系统回收掉，Activity就处于Killed状态

如果一个活动在处于停止或者暂停的状态下，系统内存缺乏时会将其结束（finish）或者杀死（kill）。这种非正常情况下，系统在杀死或者结束之前会调用onSaveInstance()方法来保存信息，同时，当Activity被移动到前台时，重新启动该Activity并调用onRestoreInstance()方法加载保留的信息，以保持原有的状态。

在上面的四中常有的状态之间，还有着其他的生命周期来作为不同状态之间的过度，用于在不同的状态之间进行转换，生命周期的具体说明见下。





3.Android四大组件

Android四大基本组件：Activity、BroadcastReceiver广播接收器、ContentProvider内容提供者、Service服务。

Activity:

应用程序中，一个Activity就相当于手机屏幕，它是一种可以包含用户界面的组件，主要用于和用户进行交互。一个应用程序可以包含许多活动，比如事件的点击，一般都会触发一个新的Activity。

BroadcastReceiver广播接收器：

应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。

ContentProvider内容提供者:

内容提供者主要用于在不同应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。只有需要在多个应用程序间共享数据时才需要内容提供者。例如：通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处：统一数据访问方式。

Service服务：

是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要长期运行的任务（一边打电话，后台挂着QQ）。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另一个应用程序，服务扔然能够保持正常运行，不过服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉后，所有依赖于该进程的服务也会停止运行（正在听音乐，然后把音乐程序退出）。

原文：https://blog.csdn.net/m0_37989980/article/details/78681367


4.app测试和web测试有什么区别？
WEB测试和App测试从流程上来说，没有区别。
都需要经历测试计划方案，用例设计，测试执行，缺陷管理，测试报告等相关活动。
从技术上来说，WEB测试和APP测试其测试类型也基本相似，都需要进行功能测试、性能测试、安全性测试、GUI测试等测试类型。

他们的主要区别在于具体测试的细节和方法有区别，比如：性能测试，在WEB测试只需要测试响应时间这个要素，在App测试中还需要考虑流量测试和耗电量测试。

兼容性测试：在WEB端是兼容浏览器，在App端兼容的是手机设备。而且相对应的兼容性测试工具也不相同，WEB因为是测试兼容浏览器，所以需要使用不同的浏览器进行兼容性测试（常见的是兼容IE6，IE8，chrome，firefox）如果是手机端，那么就需要兼容不同品牌，不同分辨率，不同android版本甚至不同操作系统的兼容。（常见的兼容方式是兼容市场占用率前N位的手机即可），有时候也可以使用到兼容性测试工具，但WEB兼容性工具多用IETester等工具，而App兼容性测试会使用Testin这样的商业工具也可以做测试。

安装测试：WEB测试基本上没有客户端层面的安装测试，但是App测试是存在客户端层面的安装测试，那么就具备相关的测试点。

还有，App测试基于手机设备，还有一些手机设备的专项测试。如交叉事件测试，操作类型测试，网络测试（弱网测试，网络切换）

交叉事件测试：就是在操作某个软件的时候，来电话、来短信，电量不足提示等外部事件。

操作类型测试：如横屏测试，手势测试

网络测试：包含弱网和网络切换测试。需要测试弱网所造成的用户体验，重点要考虑回退和刷新是否会造成二次提交。弱网络的模拟，据说可以用360wifi实现设置。

从系统架构的层面，WEB测试只要更新了服务器端，客户端就会同步会更新。而且客户端是可以保证每一个用户的客户端完全一致的。但是APP端是不能够保证完全一致的，除非用户更新客户端。如果是APP下修改了服务器端，意味着客户端用户所使用的核心版本都需要进行回归测试一遍。

还有升级测试：升级测试的提醒机制，升级取消是否会影响原有功能的使用，升级后用户数据是否被清除了。

原文地址：https://www.cnblogs.com/laoluoits/p/5673291.html



5.android和ios测试区别？

App测试中ios和Android有哪些区别呢？
1.Android长按home键呼出应用列表和切换应用，然后右滑则终止应用；
2.多分辨率测试，Android端20多种，ios较少；
3.手机操作系统，Android较多，ios较少且不能降级，只能单向升级；新的ios系统中的资源库不能完全兼容低版本中的ios系统中的应用，低版本ios系统中的应用调用了新的资源库，会直接导致闪退（Crash）；
4.操作习惯：Android，Back键是否被重写，测试点击Back键后的反馈是否正确；应用数据从内存移动到SD卡后能否正常运行等；
5.push测试：Android：点击home键，程序后台运行时，此时接收到push，点击后唤醒应用，此时是否可以正确跳转；ios，点击home键关闭程序和屏幕锁屏的情况（红点的显示）；
6.安装卸载测试：Android的下载和安装的平台和工具和渠道比较多，ios主要有app store，iTunes和testflight下载；
7.升级测试：可以被升级的必要条件：新旧版本具有相同的签名；新旧版本具有相同的包名；有一个标示符区分新旧版本（如版本号），
对于Android若有内置的应用需检查升级之后内置文件是否匹配（如内置的输入法）

另外：对于测试还需要注意一下几点：
1.并发（中断）测试：闹铃弹出框提示，另一个应用的启动、视频音频的播放，来电、用户正在输入等，语音、录音等的播放时强制其他正在播放的要暂停；
2.数据来源的测试：输入，选择、复制、语音输入，安装不同输入法输入等；
3.push（推送）测试：在开关机、待机状态下执行推送，消息先死及其推送跳转的正确性；
应用在开发、未打开状态、应用启动且在后台运行的情况下是push显示和跳转否正确；
推送消息阅读前后数字的变化是否正确；
多条推送的合集的显示和跳转是否正确；

4.分享跳转：分享后的文案是否正确；分享后跳转是否正确，显示的消息来源是否正确；

5.触屏测试：同时触摸不同的位置或者同时进行不同操作，查看客户端的处理情况，是否会crash等

原文链接：https://www.jianshu.com/p/91d7acfb036e



6.app出现ANR，是什么原因导致的？

那么导致ANR的根本原因是什么呢？简单的总结有以下两点：

1.主线程执行了耗时操作，比如数据库操作或网络编程
2.其他进程（就是其他程序）占用CPU导致本进程得不到CPU时间片，比如其他进程的频繁读写操作可能会导致这个问题。

细分的话，导致ANR的原因有如下几点：
1.耗时的网络访问
2.大量的数据读写
3.数据库操作
4.硬件操作（比如camera)
5.调用thread的join()方法、sleep()方法、wait()方法或者等待线程锁的时候
6.service binder的数量达到上限
7.system server中发生WatchDog ANR
8.service忙导致超时无响应
9.其他线程持有锁，导致主线程等待超时
10.其它线程终止或崩溃导致主线程一直等待。

原文：https://blog.csdn.net/jaychou_maple/article/details/78782822



7.App出现crash原因有哪些？

为什么App会出现崩溃呢？百度了一下，查到和App崩溃相关的几个因素：内存管理错误，程序逻辑错误，设备兼容，网络因素等，如下：
1.内存管理错误​：可能是可用内存过低，app所需的内存超过设备的限制，app跑不起来导致App crash。
或是内存泄露，程序运行的时间越长，所占用的内存越大，最终用尽全部内存，导致整个系统崩溃。
亦或非授权的内存位置的使用也可能会导致App crash。
2.程序逻辑错误：​数组越界、堆栈溢出、并发操作、逻辑错误。
e.g. app新添加一个未经测试的新功能，调用了一个已释放的指针，运行的时候就会crash。
3.​设备兼容：由于设备多样性，app在不同的设备上可能会有不同的表现。
​4.网络因素：可能是网速欠佳，无法达到app所需的快速响应时间，导致app crash。或者是不同网络的切换也可能会影响app的稳定性。

原文：https://blog.csdn.net/yangtuxiaojie/article/details/47123243



8.app对于不稳定偶然出现anr和crash时候你是怎么处理的？

app偶然出现anr和crash是比较头疼的问题，由于偶然出现无法复现步骤，这也是一个测试人员必备的技能，需要抓日志。查看日志主要有3个方法：

方法一：app开发保存错误日志到本地
一般app开发在debug版本，出现anr和crash的时候会自动把日志保存到本地实际的sd卡上，去对应的app目录取出来就可以了

方法二：实时抓取
当出现偶然的crash时候，这时候可以把手机拉到你们app开发那，手机连上他的开发代码的环境，有ddms会抓日志，这时候出现crash就会记录下来日志。
尽量重复操作让bug复现就可以了

也可以自己开着logcat，保存日志到电脑本地,参考这篇：https://www.cnblogs.com/yoyoketang/p/9101365.html

adb logcat | find "com.sankuai.meituan" >d:\hello.txt

方法三：第三方sdk统计工具

一般接入了第三方统计sdk,比如友盟统计，在友盟的后台会抓到报错的日志



9.app的日志如何抓取?

app本身的日志，可以用logcat抓取,参考这篇：https://www.cnblogs.com/yoyoketang/p/9101365.html

adb logcat | find "com.sankuai.meituan" >d:\hello.txt

也可以用ddms抓取，手机连上电脑，打开ddms工具，或者在Android Studio开发工具中，打开DDMS



关于ddms更多的功能，参考这篇：https://www.cnblogs.com/gaobig/p/5029381.html



10.logcat查看日志步骤

做app测试，遇到异常情况，查看日志是必不可少的，日志如何输出到手机sdcard和电脑的目录呢？这就需要用logcat输出日志了
以下操作是基于windows平台的操作：adb logcat | find
linux平台的操作可以把find改成grep： adb logcat | grep
windows上的dos里面是没grep指令的

logcat输出日志
1.把日志存入手机sdcard某个目录(前提是这个目录要是存在的)

adb logcat -f /sdcard/yoyo/yoyo.txt

备注：-f将日志输出到文件

上面这个指令在真机上（未root)是会报错的，提示没操作权限，在模拟器上可以执行



2.把日志存入电脑的某个目录，如d:\debug

adb logcat >d:debug\yoyo.txt



备注这里没-f， 不要问为什么

find过滤包名
1.如果直接用adb logcat抓日志的话，会把系统的一些其他无关紧要的都抓出来，如果只想抓取被测app的日志，那就根据包名过滤

adb logcat | find "com.sankuai.meituan" >d:\hello.txt



结束logcat
1.结束logcat抓包，可以用ctr+c快捷键结束， 这个是通过手工的快捷键操作完成

2.也可以先查询到logcat的pip，再kill掉

adb shell ps | findstr logcat

adb shell kill -9 [logcatpid]

注意：kill操作在模拟器上是可以的，真机上没权限



help其它功能
1.cmd输入adb logcat -help可以查看其它功能

adb logcat -help

C:\Users\admin>adb logcat -help
Unrecognized Option h
Usage: logcat [options] [filterspecs]
**选项**:
-- "-s"选项 : 设置输出日志的标签, 只显示该标签的日志;

-- "-f"选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;

-- "-r"选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;

-- "-n"选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;

-- "-v"选项 : 设置日志的输出格式, 注意只能设置一项;

-- "-c"选项 : 清空所有的日志缓存信息;

-- "-d"选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;

-- "-t"选项 : 输出最近的几行日志, 输出完退出, 不阻塞;

-- "-g"选项 : 查看日志缓冲区信息;

-- "-b"选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;

-- "-B"选项 : 以二进制形式输出日志;

**过滤项格式** : <tag>[:priority] , 标签:日志等级, 默认的日志过滤项是 " *:I " ;

-- V : Verbose (明细);

-- D : Debug (调试);

-- I : Info (信息);

-- W : Warn (警告);

-- E : Error (错误);

-- F : Fatal (严重错误);

-- S : Silent(Super all output) (最高的优先级, 可能不会记载东西);

'*' by itself means '*:D' and <tag> by itself means <tag>:V.
If no '*' filterspec or -s on command line, all filter defaults to '*:V'.
eg: '*:S <tag>' prints only <tag>, '<tag>:S' suppresses all <tag> log messages.

If not specified on the command line, filterspec is set from ANDROID_LOG_TAGS.

If not specified with -v on command line, format is set from ANDROID_PRINTF_LOG
or defaults to "threadtime"
10.你平常会看日志吗, 一般会出现哪些异常

这个主要是面试官考察你会不会看日志，是不是看得懂java里面抛出的异常，Exception

一般面试中java Exception（runtimeException ）是必会被问到的问题
app崩溃的常见原因应该也是这些了。常见的异常列出四五种，是基本要求。

常见的几种如下：

NullPointerException - 空指针引用异常
ClassCastException - 类型强制转换异常。
IllegalArgumentException - 传递非法参数异常。
ArithmeticException - 算术运算异常
ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
IndexOutOfBoundsException - 下标越界异常
NegativeArraySizeException - 创建一个大小为负数的数组错误异常
NumberFormatException - 数字格式异常
SecurityException - 安全异常
UnsupportedOperationException - 不支持的操作异常



回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-30 10:30:35 6#
七、抓包工具
fiddler
Wireshark

一、fiddler
如何使用Fiddler抓取手机上的数据包？
数据包中都包含哪些内容？
如何设置AutoResponder?
如何使用Fiddler发送Get/Post请求?
如何使用Fiddler构造慢网络？
如何使用Fiddler抓取https包?

1.如何使用Fiddler抓取手机上的数据包？
1.PC端设置

2.手机端设置置



2.数据包中都包含哪些内容？

1.状态码、协议类型

2.Request ( Header: User-Agent, Cookies, Referer)

3.Response (Header, Data)



3.如何设置AutoResponder?

1,抓取请求.

2.制作数据

3.设置规则



4.如何使用Fiddler发送Get/Post请求?

1·构造URL ( Get&Post )

2.构造参数( Get&Post )

3·构造数据( Post )



5.如何使用Fiddler构造慢网络？

1.Rules→ Performances →Simulate Modem Speeds

2,修改代码,配置需要的速度



6.如何使用Fiddler抓取https包?

1.Fiddler https相关设置



[端口号：8888]



2·在浏览器中安装证书






回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-30 10:45:13 7#
八、数据库
SQL学生表 — 1
SQL学生表 — 2
SQL查询 — 3
SQL经典面试题 — 4

1.SQL学生表 — 1
前言
每次面试必考SQL,小编这几年一直吃SQ的亏，考题无非就是万年不变学生表，看起来虽然简单，真正写出来，还是有一定难度。于是决定重新整理下关于SQL的面试题，也可以帮助更多的人过SQL这一关。
作为一个工作3年以上测试人员，不会sql基本上能拿到offer的希望渺茫，虽然平常也会用到数据库，都是用的简单的查询语句。困难一点的就直接找开发了，面试想留个好印象，还是得熟练掌握，能在纸上快速写出来。

1.查询所有学生的数学成绩，显示学生姓名name, 分数， 由高到低
2.统计每个学生的总成绩,显示字段：姓名，总成绩
3.统计每个学生的总成绩（由于学生可能有重复名字）,显示字段：学生id，姓名，总成绩
4.列出各门课程成绩最好的学生， 要求显示字段: 学号，姓名,科目，成绩
5.列出各门课程成绩最好的2位学生， 要求显示字段: 学号，姓名, 科目，成绩
万年不变学生表
有2张表，学生表（student）基本信息如下



科目和分数表（grade）



排序order by
1.查询所有学生的数学成绩，显示学生姓名name, 分数， 由高到低

SELECT a.name, b.score
FROM student a, grade b
WHERE a.id = b.id
AND kemu = '数学'
ORDER BY score
DESC


统计总成绩sum

2.统计每个学生的总成绩,显示字段：姓名，总成绩



SELECT a.name, sum(b.score) as sum_score
FROM student a, grade b
WHERE a.id = b.id
GROUP BY name
DESC




统计总成绩

3.统计每个学生的总成绩（由于学生可能有重复名字）,显示字段：学生id，姓名，总成绩



SELECT a.id, a.name, c.sum_score
from student a, 
(SELECT b.id, sum(b.score) as sum_score
FROM grade b
GROUP BY id
) c
WHERE a.id = c.id
ORDER BY sum_score
DESC


统计单科最好成绩

4.列出各门课程成绩最好的学生， 要求显示字段: 学号，姓名,科目，成绩



第一步先group by找出单科最好成绩，作为第一张表



SELECT b.kemu, MAX(b.score)
FROM grade b
GROUP BY kemu


再结合学生表和分数表，得到单科最好成绩



-- 单科最好的成绩
SELECT c.id , a.name, c.kemu, c.score

FROM grade c, student a,
(SELECT b.kemu, MAX(b.score) as max_score
FROM grade b
GROUP BY kemu) t
WHERE c.kemu = t.kemu
AND c.score = t.max_score
AND a.id = c.id


总结 group by相关用法

函数	作用	支持性
sum(列名)	求和	
max(列名)	最大值	
min(列名)	最小值	
avg(列名)	平均值	
first(列名)	第一条记录	仅Access支持
last(列名)	最后一条记录	仅Access支持
count(列名)	统计记录数	注意和count(*)的区别
各门课程成绩最好的2位学生

5.列出各门课程成绩最好的2位学生， 要求显示字段: 学号，姓名, 科目，成绩

SELECT t1.id, a.name, t1.kemu,t1.score
FROM grade t1, student a
WHERE
    (SELECT count(*) FROM grade t2 
    WHERE t1.kemu=t2.kemu AND t2.score>t1.score
    )<2
and a.id = t1.id
ORDER BY t1.kemu,t1.score 
DESC


2.SQL学生表 — 2
接着上一篇https://www.cnblogs.com/yoyoketang/p/10065424.html，继续学生表SQL

1.计算每个人的平均成绩， 要求显示字段: 学号，姓名，平均成绩
2.计算每个人的成绩，总分数，平均分，要求显示：学号，姓名，语文，数学，英语，总分，平均分
3.列出各门课程的平均成绩，要求显示字段：课程，平均成绩
4.列出数学成绩的排名， 要求显示字段：学号，姓名，成绩，排名
万年不变学生表
有2张表，学生表（student）基本信息如下



科目和分数表（grade）



计算学生平均分数
1.计算每个人的平均成绩， 要求显示字段: 学号，姓名，平均成绩

select  a.id, a.name, c.avg_score 
from student a,
(select b.id, avg(b.score) as avg_score 
from grade  b
group by b.id
)c
where a.id = c.id


统计各科目成绩
2.计算每个人的成绩，总分数，平均分，要求显示：学号，姓名，语文，数学，英语，总分，平均分

使用case when 语法把科目字段分解成具体的科目：语文，数学， 英语

select a.id as 学号, a.name as 姓名, 
(case when b.kemu='语文' then score else 0 end) as 语文,
(case when b.kemu='数学' then score else 0 end) as 数学,
(case when b.kemu='英语' then score else 0 end) as 英语
from student a, grade b
where a.id = b.id

SELECT a.id as 学号, a.name as 姓名, 
sum(case when b.kemu='语文' then score else 0 end) as 语文,
sum(case when b.kemu='数学' then score else 0 end) as 数学,
sum(case when b.kemu='英语' then score else 0 end) as 英语,
sum(b.score) as 总分 ,
sum(b.score)/count(b.score) as 平均分
FROM student a, grade b
where a.id = b.id
GROUP BY b.id, b.id


每门课程平均成绩
3.列出各门课程的平均成绩，要求显示字段：课程，平均成绩

select b.kemu, avg(b.score)
from grade b
group by b.kemu


成绩排名
4.列出数学成绩的排名， 要求显示字段：学号，姓名，成绩，排名

在查询结果表里面添加一个变量@paiming,让它自动加1

SELECT
t.id, t.score as 数学分数,  @paiming := @paiming+1 as 排名
FROM
    (SELECT b.id, b.score
    FROM grade b
  WHERE b.kemu = '数学'
    ORDER BY score 
    DESC) AS t,
 (SELECT @paiming := 0) r

结合student表获取学生名称

SELECT
t.id, a.name,t.score as 数学分数,  @paiming := @paiming+1 as 排名
FROM
    (SELECT b.id, b.score
    FROM grade b
  WHERE b.kemu = '数学'
    ORDER BY score 
    DESC) AS t,
 (SELECT @paiming := 0) r,
  student a
WHERE a.id = t.id


同结果名次相同
上图由于同一个分数的小伙伴，排名不一样，本着公平、公正、公开的原则，同一分数名次一样

SELECT
t.id, a.name,t.score as 数学分数, 
(CASE
WHEN @temp = t.score THEN
    @paiming
WHEN @temp := t.score THEN
    @paiming :=@paiming + 1
WHEN @temp = 0 THEN
    @paiming :=@paiming + 1
END) AS num

FROM
    (SELECT b.id, b.score
    FROM grade b
  WHERE b.kemu = '数学'
    ORDER BY score 
    DESC) AS t,
 (SELECT @paiming := 0, @temp := 0) r,
  student a
WHERE a.id = t.id

排名相同的占个名次
SELECT  obj.id, obj.score as 数学,
    @rownum := @rownum + 1 AS num_tmp,
    @incrnum := (CASE
WHEN @rowtotal = obj.score THEN
   @incrnum
WHEN @rowtotal := obj.score THEN
   @rownum
END) AS 排名

FROM
(SELECT id, score
FROM grade
WHERE kemu = "数学"
ORDER BY
score DESC
) AS obj,
(SELECT @rownum := 0 ,@rowtotal := NULL ,@incrnum := 0) r


3.SQL查询 — 3
前言
select top n 形式的语句可以获取查询的前几个记录,但是 mysql没有此语法,mysql用limit来实现相关功能。
LIMIT子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。
如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。

1.列出数学成绩前3名的学生（要求显示字段：学号，姓名, 科目，成绩）
2.查询数学成绩第2和第3名的学生
3.查询第3名到后面所有的学生数学成绩
4.统计英语课程少于80分的，显示 学号id, 姓名，科目，分数
5.查找每科成绩前2名，显示id, 姓名，科目，分数
万年不变学生表
有2张表，学生表（student）基本信息如下

科目和分数表（grade）

查询前3名
1.列出数学成绩前3名的学生（要求显示字段：学号，姓名, 科目，成绩）

select  * 
from grade 
where kemu = '数学'
order by score 
desc
limit 3

先通过limit取出前三条记录，再结合student表查询

select  a.id, a.name, b.kemu, b.score
from student a, grade b
where a.id = b.id
and kemu = '数学'
order by score 
desc
limit 3

查询第2-3名记录
2.查询数学成绩第2和第3名的学生

imit后面如果只写一个整数n，那就是查询的前n条记录；如果后面带2个整数n 和 m，那么第一个数n就是查询出来队列的起点（从0开始），第二个是m是统计的总数目
第2-3条记录，那么起点就是1， 第2-3名有2条记录，那么第二个参数就是2

select  a.id, a.name, b.kemu, b.score
from student a, grade b
where a.id = b.id
and kemu = '数学'
order by score 
desc
limit 1, 2


备注：limit是按条数取的，名次一样的，也算一个记录。如果取第5-14的记录，那就是limit 4 10

查询第3到后面所有的

3.查询第3名到后面所有的学生数学成绩

select  a.id, a.name, b.kemu, b.score
from student a, grade b
where a.id = b.id
and kemu = '数学'
order by score 
desc
limit 2, 10000
注意：有些资料上写的limit 2, -1 用-1代码最大值，这个是不对的，会报错，解决办法：随便写个非常大的整数


英语课程少于80分的人
4.统计英语课程少于80分的，显示 学号id, 姓名，科目，分数

SELECT a.id, a.name, b.kemu, b.score
FROM student a, grade b
WHERE a.id = b.id
AND b.kemu = '英语'
AND b.score < 80


统计每门课程不及格、一般、优秀
课程	不及格（80）
SELECT b.kemu, 

(SELECT COUNT(*) FROM grade WHERE score < 60 and kemu = b.kemu) as 不及格,
(SELECT COUNT(*) FROM grade WHERE score between 60 and 80 and kemu = b.kemu) as 一般,
(SELECT COUNT(*) FROM grade WHERE score > 80 and kemu = b.kemu) as 优秀
 
FROM grade b
GROUP BY kemu


查找每科成绩前2名
5.查找每科成绩前2名，显示id, 姓名，科目，分数

先按科目和分数查询

SELECT t1.id, t1.kemu,t1.score 
FROM grade t1 
ORDER BY t1.kemu,t1.score DESC

再查找每个每科前面2名

SELECT t1.id, a.name, t1.kemu,t1.score
FROM grade t1, student a
WHERE
    (SELECT count(*) FROM grade t2 
    WHERE t1.kemu=t2.kemu AND t2.score>=t1.score
    )<=2
and a.id = t1.id
ORDER BY t1.kemu,t1.score 
DESC


如果第二名有重复的，也能一起查找出来

SELECT t1.id, a.name, t1.kemu,t1.score
FROM grade t1, student a
WHERE
    (SELECT count(*) FROM grade t2 
    WHERE t1.kemu=t2.kemu AND t2.score>t1.score
    )<2
and a.id = t1.id
ORDER BY t1.kemu,t1.score 
DESC

4.SQL经典面试题 — 4
前言
用一条SQL 语句查询xuesheng表每门课都大于80 分的学生姓名，这个是面试考sql的一个非常经典的面试题

having和not in
查询 xuesheng表每门课都大于80 分的学生姓名

name	kecheng	score
张三	语文	81
张三	数学	73
李四	语文	86
李四	数学	90
王五	数学	89
王五	语文	88
王五	英语	96
解决办法一： having
如果不考虑学生的课程少录入情况（比如张三只有2个课程，王五有3个课程）

SELECT name 
FROM xuesheng 
GROUP BY name
HAVING MIN(score)> 80
如果考虑学生的课程数大于等于3的情况

SELECT name 
FROM xuesheng 
GROUP BY name
HAVING MIN(score)> 80
AND COUNT(kecheng)>=3
解决办法二：not in
可以用反向思维，先查询出表里面有小于80分的name,然后用not in去除掉

SELECT DISTINCT name 
FROM xuesheng 
WHERE name NOT IN
    (SELECT DISTINCT name 
    FROM xuesheng 
    WHERE score <=80);


删除
学生表xueshengbiao 如下:自动编号 学号 姓名 课程编号 课程名称 分数

autoid	id	name	kcid	kcname	score
1	2005001	张三	0001	数学	69
2	2005002	李四	0001	数学	89
3	2005001	张三	0001	数学	69
删除除了自动编号不同, 其他都相同的学生冗余信息

DELETE t1 
FROM xueshengbiao t1, xueshengbiao t2
WHERE t1.id = t2.id
and t1.name = t2.name
and t1.kcid = t2.kcid
and t1.kcname = t2.kcname
and t1.score = t2.score
and t1.autoid < t2.autoid


如果只是查询出自动编号不同, 其他都相同的学生冗余信息，可以用group by

SELECT * from xueshengbiao t1
WHERE t1.autoid
NOT IN
    (SELECT MIN(autoid) as autoid FROM xueshengbiao
    GROUP BY id, name, kcid, kcname, score)


模糊查询%
表名：student ，用sql查询出“张”姓学生中平均成绩大于75分的学生信息；

name	kecheng	score
张青	语文	72
张华	英语	81
王华	数学	72
张青	物理	67
李立	化学	98
张青	化学	76
select * from student
where name in 
(select name from student
where name like '张%' group by name having avg(score) > 75);
SQL 通配符
在 SQL 中，通配符与 SQL LIKE 操作符一起使用。SQL 通配符用于搜索表中的数据。在 SQL 中，可使用以下通配符：

通配符	描述
%	替代 0 个或多个字符
_	替代一个字符
[charlist]	字符列中的任何单一字符
[^charlist]或[!charlist]	不在字符列中的任何单一字符
MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式

找出姓张和姓李的同学, 用rlike实现匹配多个

-- 找出姓张和姓李的
select * from xuesheng
where name in 
(select name from xuesheng
where name rlike '[张李]' group by name having avg(score) > 75);
也可以用 REGEXP，结合正则匹配

select * from xuesheng
where name in 
(select name from xuesheng
where name REGEXP '^[张李]' group by name having avg(score) > 75);

回复
刘秋萍
image
1
主题
0
积分
发表于:2020-10-30 10:55:28 8#
九、安全/渗透测试
1.安全性测试都包含哪些内容？
1,用户访问认证

2.传输数据加密

3.安全防护策略:如安全日志、入侵检测、隔离防护、漏洞扫描

4.数据备份与恢复

5.防病毒系统

6.SQL注入、JS注入

十、开放性思维题

搜索输入框怎么进行测试？
对电梯进行测试用例设计
对杯子进行测试用例设计
对桌子进行测试用例设计
对洗衣机进行测试用例设计

1.搜索输入框怎么进行测试？
回答思路：
确认面试题目：在不清楚题目的情况下
(1).先确认一下问题，是说仅测试输入框，不考虑页面其他内容吗？
(2).是的，仅有输入框不考虑页面其他元素。

大的范围：功能性、兼容性、稳定性、性能、安全、接口、线上监控、自动化。这几大方面去考虑。
小的范围：功能性、兼容性、安全性。

关于功能性测试：
(1).常规可输入的内容，数字、字符串、特殊字符、转义字符等等。
(2).非常规有一定含义的，html标签、css、javascript代码、url等
(3).输入内容的边界，空字符、超长文本（边界值+1，-1）

关于兼容性测试
(1).根据产品的用户分布，手机品牌、分辨率、选择 topN 机型
(2).根据产品在不同浏览器上的占有率，选择主要的浏览器测试
(3).关注的问题，页面渲染、页面布局等，借助 firebug 调试

关于稳定性测试
(1).在某一压力下，搜索时，结果可以正常返回
(2).多次查询，返回的内容相对稳定

关于性能测试
(1).QPS , Query Per Second ,每秒钟能处理的请求数
(2).从点击开始到页面完全加载,平均耗时情况
(3).加载的页面大小,资源(JS, CSS文件)的数量等

关于安全测试
(1).JS注入
(2).SQL注入

关于接口测试
(1).查询接口的正确性验证
(2).查询接口对一些异常数据的容错情况
(3).查询接口在非浏览器环境下的处理情况

关于线上监控
(1).保证线上服务的质量,建立实时监控
(2).及时发现异常情况,降低对用户的影响

关于自动化
(1).基于Selenium 实现UI自动化
(2).例行回归验证,提高效率
(3).Android使用Appium基于UIAutomator , iOS使用WDA


2.对电梯进行测试用例设计
电梯测试
套用万能公式（也就是质量模型，也叫软件质量的6大特性）

界面测试：

查看电梯外观，按钮位设计是否合理、大方、美观，是否有温馨提示的标语。

是否有检修标牌和紧急求助联系方式。

功能测试：

1.测试电梯能否实现正常的上升和下降功能。

2.电梯的按钮是否都可以使用。

3.电梯门的打开，关闭是否正常。

4.报警装置是否可用。

5.与其他电梯之间是否协作良好。

6.通风状况如何。

7.突然停电时的情况。

8.上升途中的响应。

1）电梯本来在1楼，如果有人在18楼按，那么电梯在上升到5楼的时候，有人在10楼按，这时候是否会在10楼先停下来；

2）电梯下降到10层时显示满员，此时若8层有人等待电梯，是否在8层停。

可靠性（安全性）：

1.门关上的一刹那出现障碍物。

2.同时按关门和开门按钮。

3.点击当前楼层号码。

4.多次点击同一楼层的号码等等。

5.同时按上键和下键会怎样。

易用性：

1.电梯的按钮的设计符合一般人使用的习惯吗．

效率（性能方面、压力测试方面）：

1.看电梯运行速度是否在符合需求（既快又安全）

2.看电梯的最大限度的承受重量．在负载过重时是否有提醒。

3.在一时间内不断的让电梯上升，下降。

4.最大负载下平稳运行的最长时间。

维护：

一旦出现故障，是否有很好的维修机制

可移植：

是否可以拆卸，用于新房子的安装



3.对杯子进行测试用例设计

界面测试:

查看杯子外观是否漂亮

功能性：

1 用水杯装水看漏不漏，水能不能被喝到

2 杯子是否能够容纳果汁、白水、酒精、汽油

可靠性（包括安全方面）：

杯子有没有毒或细菌，杯子从不同高度落下的损坏程度

易用性：

是否有防滑措施、是否方便饮用、杯子是否烫手、

效率（性能、压力方面）：

是否容易损坏，测试杯子抗破碎强度。

维护：

破损后，有没有修补措施

可移植性（包含兼容性）：

测试杯子在不同的地方、温度等环境下的使用情况



4.对桌子进行测试用例设计

需求测试:查看国家相关标准。

功能:桌子是办公,或者放置用的,首先考虑桌子的面积大小是否适度.

界面:桌子的版面是否平滑,桌子有没有凹凸不平的地方

安全:桌子肯定有它的支撑点,若支撑点不稳,容易摔坏物品,使用起来也不方便.

易用:桌子的移动性好不.它的重量是否合适

可靠性:将桌子推倒后,再检查桌子是否很容易被损坏.

性能:将很重的物品放在桌子上,看它最大承受的重量是多少...



5.对洗衣机进行测试用例设计

功能测试：该洗衣机是否能正常的洗衣服

需求测试：查看洗衣机的使用说明书和安全说明书等

性能测试：使用时用电量如何，是否满足用户需求

界面测试：洗衣机的外观是否满足客户的需求

易用测试： 该洗衣机是否容易操作

兼用性测试：该洗衣机除了能洗衣服以外还能洗别的吗

安全性测试：该洗衣机通电以后人接触以后是否有电

负载测试：通过逐步增加系统负载，最终确定在什么负载条件下系统性能将处于崩溃状态，以此获得系统能提供的最大服务

压力测试：通过逐步增加系统负载，最终确定在什么负载条件下系统性能将处于崩溃状态，以此获得系统能提供的最大服务级别的测试。

稳定性测试：加到一定的衣服然后过一段时间看洗衣机是否正常洗



十一、项目相关

1.测试工作流程







回复
